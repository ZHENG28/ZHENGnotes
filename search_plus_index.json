{"./":{"url":"./","title":"README","keywords":"","body":"【低版本node】 gitbook init：生成gitbook gitbook serve：预览网页 1) 地址：http://localhost:4000/ 2) 运行后会生成_book文件夹 "},"trivial/STUDY/markdown.html":{"url":"trivial/STUDY/markdown.html","title":"markdown语法","keywords":"","body":"1 基础语法 1.1 标题 几个#表示几级标题 插件anchor-navigation-ex会给##自动加上1.1. 1.2 换行 行尾加2个空格 + 回车 = 换行 一个空格： &nbsp;：No-Break Space，按下space键产生的空格 两个空格： &ensp;：En Space，em的一半 四个空格： &emsp;：Em Space，一个中文字的宽度 1.3 强调 斜体效果：*斜体1* 或 _斜体2_ 加粗效果：**加粗1** 或 __加粗2__ 删除线效果：~~删除线~~ 1.4 列表 无序列表：- 或 * 有序列表：1. 任务列表：- [ ] 与 - [x] [ ] 第一个todo [ ] 第二个todo [x] 第三个todo [!DANGER] 插件安装失败，TODO勾选框无法正常显示 1.5 链接 Github Go to Baidu 1.6 引用 几个>表示几个引用嵌套 要跳出引用，只需打一个空行即可 这是第一行 这是第二行 这是第三行 这是在外面 1.7 分割线 --- *** ___ 1.8 代码块 行内代码：` function add(x, y) { return x + y; } 块代码：``` function add(x, y) { return x + y; } 1.9 表格 代码： | a | b | c | | :--: | :--: | :--: | | 1 | 2 | 3 | | 4 | 5 | 6 | 效果： a b c 1 2 3 4 5 6 2 数学 2.1 公式 类似于Latex 行内显示：f(x)=x+12 f(x)=x+12 f(x)=x+12 块显示： ∑n=1100n\r \\sum_{n=1}^{100} n\r ∑​n=1​100​​n 常用符号 3 文件导入 3.1 支持的格式 图片：.jpg .gif .png .svg .bmp 表格：.csv 网页：.html 文件：.pdf 代码：@import \"file_name\" {formatter} 4 图表 4.1 流程图 graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] 4.2 支持的其他语言和图 sequence diagrams mermaid PlantUML WaveDrom GraphViz Vega & Vega-lite Ditaa 5 字体样式（以HTML的方式定义） 5.1 颜色 in: Blueout: Blue [!TIP] 可以使用颜色的单词或者Hex格式来定义颜色 5.2 字体 in: This is Times New Romanout: This is Times New Roman 6 幻灯片的制作 To see my first slide "},"trivial/STUDY/frontend.html":{"url":"trivial/STUDY/frontend.html","title":"HTML知识点","keywords":"","body":"1. 标记 概念：head标签，在HTML语法范畴之内，与js、java都无关 作用范围：只对当前网页中的所有相对路径起作用，绝对路径不起作用 格式：request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + request.getContextPath() + \"/\" ServletRequest的方法： String getScheme()：返回架构的名字，如http、https、ftp等 String getServerName()：返回服务器的主机名 int getServerPort()：返回端口号 如：http://localhost:8080/webappname/ （相对路径的资源加上base中的路径地址后，即为http://localhost:8080/webappname/path） 2. document.all.idName.xxx document.all：获取整个网页中的dom元素，返回一个集合，该集合中存放了当前网页中的所有dom元素 document.all.idName：获取id=\"idName\"的元素，等同于document.getElementById(\"idName\") 3. ES6中，可以使用反引号``来完成字符串的拼接 其中可用${}来引用变量 4. cookie、session、token的区别 Notes： session和token之间差一个签名signal，session容易被伪造，而token中因为使用了本系统特定的signal，导致token在解析后更易被证明真伪。 token中的信息是明文保存的，因此不应该在token中保存类似密码的敏感信息。 session id需要被保存在服务器端，这样大大增加了服务器的压力；而token只需要服务器端生成与认证即可。 定义三者： Cookie：浏览器里能永久存储的一种数据。由服务器生成，发送给浏览器，浏览器将其以k-v的形式保存；下一次请求时，浏览器会自动将这些cookie发送给服务器。 Session：会话，服务器需要知道当前发送的请求是属于谁的，即服务器要给每个客户端分配不同的身份标识，在浏览器中默认存在cookie中。（若web服务器做了负载均衡，则下一个操作请求到了另一台服务器时session会丢失） Token：多用户下处理认证的最佳方式，具有无状态可扩展、支持移动设备、跨程序调用、安全等特性。（需要设置服务器属性Access-Control-Allow-Origin: *，以便于让服务器能够接收到来自所有域的请求） 基于服务器的验证方式的弊端： Session：每次用户发起请求时，服务器都需要创建一个session来存储信息->增大内存的开销 可扩展性：服务器的负载均衡 CORS：跨域请求资源的失败 CSRF：用户容易受到跨站请求伪造的攻击 "},"trivial/STUDY/java.html":{"url":"trivial/STUDY/java.html","title":"java知识点","keywords":"","body":"1. 类与类之间的关系 泛化关系：A is a B(extends) 实现关系：A like a B(implements) 关联关系：A has a B，在A对象中含有B对象的引用，但比泛化弱（单向/双向） 聚合关系：特殊的关联关系，整体和部分之间的关系，整体不会决定部分的生命周期 合成关系：特殊的关联关系，整体和部分之间的关系，整体会决定部分的生命周期 依赖关系：主要体现在局部变量上，类和类体中的局部变量之间的关系，方法执行结束，该局部变量内存就消失了 2. 可变长参数（反射机制） 如果方法中有一个方法参数可以精确匹配，则不再执行可变长参数的方法 可变长参数可以当作数组处理 3. 反射机制 // 只使用类加载机制，不返回任何值 Class.forName(\"完整类名\"); // 操作这个类中的其他字节码，例如：方法、构造、字段/属性等，可以返回值 Class c = Class.forName(\"完整类名\"); 4. 面向横切面的编程方式AOP(Aspect Oriented Programming) 将与业务无关的功能从业务流程中剥离出来，形成一个独立的组件，将这个组件以横向的方式交叉地应用到业务当中的一种编程方式 5. 输入流和输出流都是相对于内存而言，到内存去是输入，从内存出来是输出 6. 序列化Serializable 定义： 完整保存住一个对象在某一状态下的信息 是一个freeze的过程，它把一个对象freeze住，然后存储，等待再次需要的时候，再将这个对象de-freeze就可以立即使用了 什么时候需要序列化： 存储对象：发现序列化操作用于存储时，一般是对于NoSql数据（而在使用Nosql数据库进行存储时，用“freeze”这个说法来理解是再恰当不过了） 数据传输 当我们让实体类实现Serializable接口（是一个空接口，没有任何方法）时，其实是在告诉JVM，此类可被默认的序列化机制序列化 "},"leetcode-master/1-array.html":{"url":"leetcode-master/1-array.html","title":"1. 数组","keywords":"","body":"1 数组理论基础 存储方式：下标从0开始，在内存空间中的地址是连续的 增删元素：需要移动大量的元素（时间复杂度）；删除的本质上是覆盖 多维数组是否是连续存储在内存中？c++中，Yes；Java中，No（类似索引表指向每一维数组存储的地址） 2 二分查找 【LC704】给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target ，如果目标值存在返回下标，否则返回-1。 你可以假设 nums 中的所有元素是不重复的 n 将在 [1, 10000] 之间 nums 的每个元素都将在 [-9999, 9999] 之间 有序数组 & 无重复元素 -> 使用二分法 二分法应当遵循循环不变量规则，即在while循环时每一次边界的处理都要坚持根据区间的定义来操作 -> 区间的定义 左闭右闭[left, right]： // 右闭 -> left == right 有意义 while (left target) right = middle - 1; 左闭右开[left, right)： // 右开 -> left == right 没有意义 while (left target) right = middle; 相关题目：LC 35、34、69（隐藏数组）、367 补充：【LC34】给你一个按照非递减顺序排列的整数数组 nums ，和一个目标值 target 。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target ，返回[-1, -1]。 存在三种情况： target在数组范围外 -> [-1, -1] target在数组范围中，但数组中不存在target -> [-1, -1] target在数组范围中，且数组中存在target -> [left, right] 拆分成寻找目标数组的左、右区间：（初学者最好一块一块的解决！） class Solution { public: vector searchRange(vector& nums, int target) { int leftBorder = getLeftBorder(nums, target); int rightBorder = getRightBorder(nums, target); // 情况一：target在数组范围外 if (leftBorder == -2 || rightBorder == -2) return {-1, -1}; // 情况三：target在数组范围中，且数组中存在target if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1}; // 情况二：target在数组范围中，但数组中不存在target return {-1, -1}; } private: int getRightBorder(vector& nums, int target) { int left = 0, right = nums.size() - 1; // right能达到-1，因此要设置-2表示未赋值 int rightBorder = -2; while (left target) { right = middle - 1; } else { // nums[middle] == target的情况也要包含，要使left划到相同目标值的最右边，即右边界 left = middle + 1; rightBorder = left; } } return rightBorder; } int getLeftBorder(vector& nums, int target) { int left = 0, right = nums.size() - 1; int leftBorder = -2; while (left 3 移除元素 【LC27】给你一个数组 nums 和一个值 val ，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 自想解法：两层for循环，外层循环数组，内层覆盖应删除元素 -> 暴力解法 双指针/快慢指针法：【适用于数组、链表、字符串等】通过双指针，在一个for循环下完成两个for循环的方法。 快指针：快速寻找要纳入新数组的元素 慢指针：指向更新后的新数组的位置 class Solution { public: int removeElement(vector& nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex 直接返回slowIndex return slowIndex; } }; 相关题目：LC 26、283、844、977（下） 4 有序数组的平方 【LC977】给你一个按非递减顺序排序的整数数组 nums ，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 自想解法：数组内元素全部平方，然后排序 -> 暴力解法 双指针法：仔细观察数组，负数平方后降序，正数平方后升序，因此可以用归并排序。 class Solution { public: vector sortedSquares(vector& nums) { vector ret(nums.size(), 0); int i = 0, j = nums.size() - 1, k = nums.size() - 1; while (i nums[j] * nums[j]) { ret[k--] = nums[i] * nums[i]; i++; } else { ret[k--] = nums[j] * nums[j]; j--; } } return ret; } }; 5 长度最小的子数组 【LC209】给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 自想解法：两个for循环嵌套，外层寻找数组的起始位置，内层寻找数组的终止位置 -> 暴力解法 滑动窗口：只用一层for循环，不断调节子序列的起始位置和终止位置，从而得到结果 起始位置的调整：如果窗口内的值满足条件，则向前移动指针 结束位置的调整：遍历的指针class Solution { public: int minSubArrayLen(int target, vector& nums) { // INT32_MAX：库常数 int result = INT32_MAX; int left = 0, sum = 0, subLength = 0; for (int right = 0; j = target) { subLength = right - left + 1; result = result 相关题目：LC 904、76（209 -> 904 -> 76：滑动窗口、哈希表unordered_map） 6 螺旋矩阵II 【LC59】给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 不涉及到算法，纯模拟过程 模拟顺时针画矩阵：上行从左到右、右列从上到下、下行从右到左、左列从下到上 要坚持循环不变量规则，保持一致的左闭右开、左开右闭的原则 class Solution { public: vector> generateMatrix(int n) { vector> matrix(n, vector(n, 0)); // 每一圈的起始坐标 int startX = 0, startY = 0; // 圈数 int loop = n / 2; // 边界长度，每循环一圈就缩减1 int margin = 1; int count = 1; int i = 0, j = 0; while (loop--) { // 上行：从左到右 for (j = startY; j startY; j--) { matrix[i][j] = count++; } // 左列：从下到上 for (; i > startX; i--) { matrix[i][startY] = count++; } startX++; startY++; margin++; } // 奇数判断：如果是，就给最中心的元素赋值 if (n % 2) { matrix[n / 2][n / 2] = n * n; } return matrix; } }; 相关题目：LC 54、29 7 总结篇 理论基础：见 1.数组理论基础 经典题目：二分、双指针、滑动窗口、模拟行为 "},"leetcode-master/2-linklist.html":{"url":"leetcode-master/2-linklist.html","title":"2. 链表","keywords":"","body":"1 链表理论基础 通过指针串在一起的线性结构，节点node = 数据域data + 指针域next，头节点为head 类型： 单链表：指针只能指向下一个节点 双链表：指针可以指向前一个节点，也能指向后一个节点（既可向前查询，又可向后查询） 循环链表：链表首尾相连（可解决约瑟夫环问题） 存储方式：散乱分布，只由指针链接（如何分配取决于内存管理） 定义： struct ListNode { // 单链表 int value; ListNode *next; ListNode(int x) : value(x), next(NULL) {} // 构造函数 }; 操作： 删除节点：将前一个节点的next指针指向后一个节点（c++中需要手动释放删除节点的内存；java中有自己的内存回收机制，因此不需要手动） 添加节点：修改节点指针域 2 移除链表元素 【LC203】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。 删除头节点要分情况讨论： 直接在原来的链表上操作：需要区分头节点和其他节点的处理方式【以下选择该方式】 设置一个虚拟头节点进行删除操作：统一处理 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { // 这里不是if，而是while，因为要删除满足条件的所有头节点 while (head != NULL && head->val == val) { // 删除多余节点，手动释放内存 ListNode* tmp = head; head = head->next; delete tmp; } ListNode* node = head; while (node != NULL && node->next != NULL) { if (node->next->val == val) { node->next = (node->next)->next; } else { node = node->next; } } return head; } }; 3 设计链表 【LC707】你可以选择使用单链表或者双链表，设计并实现自己的链表。单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 4 翻转链表 【LC206】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。 5 两两交换链表中的节点 【LC206】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。 6 删除链表的倒数第N个节点 【LC206】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。 7 链表相交 【LC206】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。 8 环形链表II 【LC206】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。 9 总结篇 理论基础：见 1.数组理论基础 "},"leetcode-master/3-hashtable.html":{"url":"leetcode-master/3-hashtable.html","title":"3. 哈希表","keywords":"","body":"1 哈希表理论基础 通过关键码的值直接访问，通常用来快速判断一个元素是否出现在集合里 哈希函数： 2 有效的字母异位词 【LC206】 3 两个数组的交集 【LC206】 4 快乐数 【LC206】 5 两数之和 【LC206】 6 四数相加II 【LC206】 7 赎金信 【LC206】 8 三数之和 【LC206】 9 四数之和 【LC206】 10 总结篇 1. "},"bjpowernode/01-Java基础/00-summary.html":{"url":"bjpowernode/01-Java基础/00-summary.html","title":"0. 小结","keywords":"","body":"[toc] Java基础 1 Java17零基础入门（略，内容同2） 2 Java零基础教程 2.1 第一节 3 IntelliJ IDEA 4 数据结构与算法（略） 5 JVM 6 设计模式 6.1 创建型create 单例（Singleton） 简单工厂（Simple Factory） 工厂方法（Factory Method） 抽象工厂（Abstract Factory） 生成器/建造者（Builder） 原型（Prototype） 6.2 行为型behavior 责任链（Chain Of Responsibility） 命令（Command） 解释器（Interpreter） 迭代器（Iterator） 中介者（Mediator） 备忘录（Memento） 观察者（Observer） 状态（State） 策略（Strategy） 模板方法（Template Method） 访问者（Visitor） 空对象（Null） 6.3 结构型structure 适配器（Adapter） 桥接（Bridge） 组合（Composite） 装饰（Decorator） 外观（Facade） 享元（Flyweight） 代理（Proxy） 7 MySQL 8 JDBC 9 Oracle（选学） "},"bjpowernode/01-Java基础/03-IntelliJ-IDEA.html":{"url":"bjpowernode/01-Java基础/03-IntelliJ-IDEA.html","title":"3. IntelliJ IDEA","keywords":"","body":"[toc] IDEA 1 VM配置文件 # 占用最大内存，调大最大内存可以减少内存回收的频率 -Xmx750m # 占用最小内存，调大最小内存可以提高Java程序的启动速度 -Xms128m # 代码占用的缓存大小 -XX:ReservedCodeCacheSize=512m # 设置文件编码格式 -Dfile.encoding=UTF-8 # 设置控制台编码格式 -Dconsole.encoding=UTF-8 2 文件结构 .iml文件是Module在该项目中的唯一标识 项目结构Project Structure： Project：本项目的基本信息 Modules： Sources：可对该Module中的开发目录进行分类，通过\"Mark as\"以便于IDEA明白应该如何对待它们 Sources：存放源代码的文件夹 Tests：存放测试代码的文件夹，一般放置@Test注解的测试代码 Resource：存放静态资源文件的文件夹（html/css/图片/音频/…），一般放置配置文件，不会编译-->Sources Test Resource：存放测试代码的文件夹，不会编译-->Tests Excluded：被排除编译的文件夹，例如out文件夹 Paths：设置Module的输出路径等 Dependencies：依赖的jar包及其依赖所涉及到的范围 export选项：如果选中，则在另一个Module中引用该Module时，被选中的jar包也会出现在另一个Module的Dependencies中 Libraries：存放各种jar包 Facets：确认相关资源的存放位置以及web项目的root路径 Artifacts：放置的是本项目中的合法Module；将web项目打包成war包，然后在tomcat发布的目录下发布 IDEA有时会对复制粘贴进来的资源无法定位，导致项目启动时存在404的错误。可以手动新建一个文件，然后将代码复制进去，这样不容易出现404的错误。 3 插件工具 HTTP Client：类似postman，访问接口的工具 Debug模式： step over：进入下一行，不进入方法 step into：进入下一行，会进入自定义方法（不会进入第三方库以及JDK的方法） force step into：进入下一行，会强制进入所有方法 step out：跳出方法体 mute breakpoints：使所有断点失效 view breakpoints：查看所有断点 resume program：直接到下一个断点处 evaluate expression：通过表达式查看值 "},"bjpowernode/01-Java基础/05-JVM.html":{"url":"bjpowernode/01-Java基础/05-JVM.html","title":"5. JVM","keywords":"","body":"[toc] JVM（Java Virtual Machine） 1 JVM概述 1.1 JVM简介 JDK、JRE、JVM三者关系： JDK（Java Development Kit）：JRE + Development/debugging tools JRE（Java Runtime Environment）：JVM + Package Classes(Compact Profiles) + Runtime Libraries JVM（Java Virtual Machine）：Class Loader System + Runtime Data Area + Execution Engine 嵌入式JDK（Embedded JDK, EJDK）：EJDK配合compact profiles以裁剪生成合适的JRE 虚拟机：虚拟的计算机，用来执行一系列虚拟的计算机指令 系统虚拟机：对物理计算机的仿真，提供可运行完整操作系统的软件平台（如VMware） 程序虚拟机：（如Java虚拟机） JVM：Java语言生成编译代码的运行平台，有自己的指令集和各种运行时内存区域；但只与特定的二进制文件格式class文件格式有关联 1.2 JVM规范 语言规范（The Java Language Specification） 虚拟机规范（The Java Virtual Machine Specification） 1.3 JVM整体结构 类加载子系统Class Loader SubSystem：在运行时，首次引用类的时候加载、链接、并初始化类文件 加载Loading：类通过该组件进行加载 启动类加载器BootStrap Class Loader：【最高优先级】负责加载来自于Bootstrap类路径的类 System.getProperty(\"sun.boot.class.path\") 加载$JAVA_HOME/jre/lib目录下的rt.jar（runtime jar） 扩展类加载器Extension Class Loader：负责加载在ext文件夹内的类 System.getProperty(\"java.ext.dirs\") 加载$JAVA_HOME/lib/ext目录下的类文件 是Bootstrap Class Loader的子类 系统类加载器Application Class Loader：负责加载应用程序级类路径CLASSPATH System.getProperty(\"java.class.path\") 加载CLASSPATH环境变量目录下的所有类文件和jar包 是Extension Class Loader的子类 链接Linking： 验证Verify：验证生成的字节码是否正确，即校验生成的.class文件是否正确 准备Prepare：给所有的静态变量分配内存地址和配置默认值（0或null） 解决Resolve：所有的符号存储器的符号引用都替换为来自Method Area的直接引用 初始化Initialization：给所有的静态变量赋予初始值，并执行静态代码块 运行时数据区Runtime Data Areas： 方法区Method Area：用于存储被JVM加载的类信息、常量、静态变量 每个JVM只有一个方法区，且是共享资源 -> 非线程安全 运行时常量池Runtime Constant Pool 堆区Heap Area：用于存储创建的对象及其对应的实例变量、数组 每个JVM只有一个堆区，且是共享资源 -> 非线程安全 栈区Stack Area： 每个线程都会创建一个单独的运行时栈 -> 线程安全 为每个调用的方法产生一个栈帧（Stack Frame）：用于存储局部变量表、操作数栈、动态链接、返回地址、帧数据区（如捕获的异常信息）等 程序计数器PC Registers：用于保存当前执行指令的物理地址（唯一一块不会出现OutOfMemoryError的区域） 每个线程都有一个单独的PC寄存器 本地方法栈Native Method Stack：保存本地方法信息 每个线程都有一个单独的本地方法堆栈 执行引擎Execution Engine：运行.class文件，即读取字节码并逐个执行 解释器Interpreter：解释字节码较快，但执行慢（未对代码优化的情况下，直接执行）；当一个方法被多次调用时，每次都需要重新解析 JIT编译器Just-In-Time Compiler：消除了解释器的缺点，即执行引擎在转换字节码时使用解释器的帮助，但当它发现重复的代码时，使用JIT编译器编译整个字节码并将其更改为本地代码（可直接用于重复的方法调用）；一次只编译执行一部分代码，并非一次性编译完全部代码 中间代码生成器Intermediate Code Generator：生成中间代码 代码优化器Code Optimizer：优化上面生成的中间代码 目标代码生成器Target Code Generator：生成机器代码或本地代码 分析器Profiler：一个特殊组件，负责查找该方法是否被多次调用 垃圾收集器Garbage Collection：收集和删除不可达对象 垃圾判断算法：引用计数法（存在相互引用使之无法通知回收的弊端）、可达性分析算法（根对象往下搜索引用链） 垃圾回收算法：标记-清除算法（存在内存碎片的问题）、复制算法（整理复制至另一半，但存在可使用内存大大减少的问题）、标记-整理算法（对内存变动过于频繁，存在效率差的问题）、分代收集算法（根据对象存活周期分为新生代、老年代等，并根据不同存活周期的特点选择不同的算法） 本地方法接口Java Native Interface：与本地方法库进行交互，并提供执行引擎所需的本地库 本地方法库Native Method Library：执行引擎所需的本地库的集合 2 class字节码文件结构 2.1 class文件的理解 Java虚拟机不与任何程序语言相关，只与class文件相关，它并不关心来源语言是什么 class文件包含了Java虚拟机指令集、符号表以及其他信息 每一个class文件对应唯一的一个类/抽象类/接口，但一个类/抽象类/接口不一定只能是class文件（如通过动态代理、类加载器等生成） class文件格式：由字节流组成，每个字节含8b；以大端在前的顺序存储 2.2 数据结构 无符号数：用于描述数字、索引引用、数量值、UTF-8编码的字符串值；连续存放，没有使用填充或对齐等调整方式 如：u1表示1个字节的无符号数，u2表示2个字节的无符号数 表：用于描述有层次关系的复合结构的数据，由多个无符号数或其他表作为数据项构成 命名以“_info”结尾 2.3 基本信息 魔数magic（u4）：固定字节的内容，用于区分文件类型，如class文件中固定为CAFEBABE 版本号version（u2+u2）： 次版本号（Minor Version）：起始值为0 主版本号（Major Version）：起始值为45，每个JDK的大版本（如JDK1.6、JDK1.8）就加1 常量池计数constant_pool_count（u2）：有效索引为1到n-1，0为保留索引 常量池constant_pool（cp_info）： 命令javap -v xxx.class：反编译字节码文件 初始化顺序：静态代码块 -> 实例代码块 -> 构造方法 数据结构： cp_info { // 标志该项常量是哪一种常量结构，一般是固定值 -> 根据常量结构计算常量所占用的字节数 u1 tag; u1 info[]; } 存放的常量类别： 字面量Literal：基本数据类型以及string类型 字符串型字面量： 普通字符串： 数据结构： CONSTANT_String_info { // 固定值为8 u1 tag; // 必须是CONSTANT_Utf8_info常量，表示某个字符串常量的索引 u2 string_index; } 所有static final修饰的或使用到的字符串字面量 UTF-8编码字符串： 数据结构： CONSTANT_Utf8_info { // 固定值为1 u1 tag; // bytes数组长度 u2 length; // 字符串内容 u1 bytes[length]; } 被final修饰的字面量（如整型、浮点型）： 整型： 数据结构： CONSTANT_Integer_info { // 固定值为3 u1 tag; // 16进制的整型值 u4 bytes; } 所有static final或final修饰的byte（-2^7到2^7-1）、char（0到2^16-1；转换成ASCII码）、short（-2^15到2^15-1）、boolean（true-1; false-0）、int类型的字面量 所有非final修饰且在short数值范围内的直接进入字节码指令内部；但超过short数值范围的进入常量池 浮点型： 数据结构： CONSTANT_Float_info { // 固定值为4 u1 tag; // 16进制的浮点值 u4 bytes; } 所有static final修饰的或使用到的浮点型字面量 长整型： 数据结构： CONSTANT_Long_info { // 固定值为5 u1 tag; // 16进制的高32区长整型值 u4 high_bytes; // 16进制的低32区长整型值 u4 low_bytes; } 所有static final修饰的或使用到的长整型字面量 双精度浮点型： 数据结构： CONSTANT_Double_info { // 固定值为6 u1 tag; // 16进制的高32区双精度浮点型值 u4 high_bytes; // 16进制的低32区双精度浮点型值 u4 low_bytes; } 所有static final修饰的或使用到的双精度浮点型字面量 符号引用Symbolic References： 字段与字段类型或方法与方法类型： 分析： 数据结构： CONSTANT_NameAndType_info { // 固定值为12 u1 tag; // 必须是CONSTANT_Utf8_info常量，表示字段与字段类型或方法与方法类型的名称 u2 name_index; // 必须是CONSTANT_Utf8_info常量，表示字段与字段类型或方法与方法类型的描述符 u2 descriptor_index; } 构造方法的名称统一使用 和字段引用（Fieldref）、方法引用（Methodref）相对应 字段描述符field descriptor：字符-类型-含义，如object类型的实例，其描述符为Ljava/lang/Object;；double类型的二维数组实例，其描述符为[[D 方法描述符method descriptor： 包含0个或多个参数描述符和返回值描述符，如Object method(int i, double d, Thread t) { ... }，其描述符为(IDLjava/lang/Thread;)Ljava/lang/Object; 实例方法还需额外传递参数this，但该传递由jvm的指令实现 类、接口的全限定名Fully Qualified Name： 数据结构： CONSTANT_Class_info { // 固定值为7 u1 tag; // 必须是CONSTANT_Utf8_info常量，表示类或接口的全限定名 u2 name_index; } 类、接口、枚举、注解、数组（在类中）的符号引用 只有在类或接口中实际使用了该类（静态代码块、成员变量、方法、方法抛异常等实例化类，方法形参、声明类等并不算实际使用），才会在常量池中找到该项 CONSTANT_Class_info常量池项默认包含两个及以上： 类Class：默认包含自身类和直接父类（如无继承，默认为继承Object类） 接口Interface：默认包含自身和Object类（隐式引用Object类，而非其父类是Object类） 枚举Enum：默认包含自身类、两个自身数组和Enum类 注解Annotation：默认包含自身、Annotation类和Object类（同Interface，隐式引用Object类） 字段的名称和描述符： 数据结构： CONSTANT_Fieldref_info { // 固定值为9 u1 tag; // 必须是CONSTANT_Class_info常量，表示当前字段所在类的类名 u2 class_index; // 必须是CONSTANT_NameAndType_info常量，表示当前字段的名称和类型描述符 u2 name_and_type_index; } 所有非static final的、引用其他类的（直接引用，不能通过getter方法）、在该类中使用的（被赋值或被引用）字段 方法的名称和描述符： 类中方法： 数据结构： CONSTANT_Methodref_info { // 固定值为10 u1 tag; // 必须是CONSTANT_Class_info常量，表示当前方法所在类的类名 u2 class_index; // 必须是CONSTANT_NameAndType_info常量，表示当前类方法的名称和类型描述符 u2 name_and_type_index; } 所有类中被调用的方法 默认调用父类的无参构造方法:()V 接口中方法： 数据结构： CONSTANT_InterfaceMethodref_info { // 固定值为11 u1 tag; // 必须是CONSTANT_Class_info常量，表示当前方法所属接口的类名 u2 class_index; // 必须是CONSTANT_NameAndType_info常量，表示当前接口方法的名称和类型描述符 u2 name_and_type_index; } 方法句柄和方法类型： 方法句柄Method Handle：虚拟机为实现动态调用InvokedDynamic指令增加的常量结构 数据结构： CONSTANT_MethodHandle_info { // 固定值为15 u1 tag; // 取值范围1-9，表示方法句柄的类型 u1 reference_kind; // 必须是CONSTANT_Utf8_info常量，表示某个常量的索引 u2 reference_index; } 方法类型Method Type：虚拟机为实现动态调用InvokedDynamic指令增加的常量结构 数据结构： CONSTANT_MethodType_info { // 固定值为16 u1 tag; // 必须是CONSTANT_Utf8_info常量，表示某个常量的索引 u2 descriptor_index; } 动态调用点和动态常量Dynamically-Computed Call Site、Dynamically-Computed Constant： 数据结构： CONSTANT_InvokeDynamic_info { // 固定值为18 u1 tag; // 指向class文件结构属性表中引导方法表的某个引导方法 u2 bootstrap_method_attr_index; // 必须是CONSTANT_NameAndType_info常量，表示 u2 name_and_type_index; } InvokedDynamic指令用到的引导方法bootstrap method以及引导方法所用到的动态调用名称、参数、返回类型 字段与字面量在常量池出现的规则： 字面量类型： static final修饰：在该类和其他类中都以字面量的形式出现 非static final修饰： 在该类中以字面量和字段（Fieldref_info）的形式出现 在其他类中以字段（Fieldref_info）的形式出现 引用类型：在该类和其他类中都以字段（Fieldref_info）的形式出现 类访问标志access_flags（u2）：用于表示某个类或者接口的访问权限属性 本类索引this_class（u2）：必须是CONSTANT_Class_info常量，表示该class文件所定义的类或接口 父类索引super_class（u2）： 类： 0：只能是Object类（它是唯一没有父类的类） CONSTANT_Class_info常量：表示该class文件所定义的类的直接父类 接口：必须是代表Object类的CONSTANT_Class_info常量 接口计数interfaces_count（u2）：表示类或接口的直接父接口 接口数组interfaces[interfaces_count]（u2）：必须是CONSTANT_Class_info常量 字段计数fields_count（u2）：表示类中定义的字段，包括静态和非静态的字段 字段数组fields[fields_count]（field_info）： 数据结构： field_info { // 表示字段访问标志 u2 access_flags; // 必须是CONSTANT_Utf8_info常量，表示字段名称索引 u2 name_index; // 必须是CONSTANT_Utf8_info常量，表示字段描述符索引 u2 descriptor_index; // 表示字段属性总数 u2 attributes_count; // 表示字段属性数组 attribute_info attributes[attributes_count]; } 字段属性类型： ConstantValue：表示静态变量（static final修饰）的初始值，且必须是基本数据类型或String类型 ConstantValue_attribute { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为ConstantValue u2 attribute_name_index; // 表示属性长度，固定为2 u4 attribute_length; // 必须是常量池中的字面量，表示常量值索引 u2 constantvalue_index; } Synthetic：类成员没有在源文件中出现，由编译器自动产生的，即动态常量 Synthetic_attribute { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为Synthetic u2 attribute_name_index; // 表示属性长度，固定为2 u4 attribute_length; } Signature：泛型签名 Synthetic_attribute { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为Signature u2 attribute_name_index; // 表示属性长度，固定为2 u4 attribute_length; // 必须是常量池中的字面量，表示签名索引 u2 signature_index; } Deprecated：过时字段 Deprecated_attribute { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为Deprecated u2 attribute_name_index; // 表示属性长度，固定为0 u4 attribute_length; } RuntimeVisibleAnnotations：运行时可见注解（JVM能反射读取），保留策略为RetentionPolicy.RUNTIME 保留策略RetentionPolicy：SOURCE（保留到.java文件中） -> CLASS（保留到.class文件中） -> RUNTIME（保留到JVM中，可反射读取） RuntimeVisibleAnnotations_attribute { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为RuntimeVisibleAnnotations u2 attribute_name_index; // 表示属性长度，固定为6 u4 attribute_length; // 表示注解数量 u2 num_annotations; // 表示注解数组 annotation annotations[num_annotations]; } RuntimelnvisibleAnnotations：运行时不可见注解（JVM不能反射读取），保留策略为RetentionPolicy.CLASS RuntimelnvisibleAnnotations_attribute { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为RuntimelnvisibleAnnotations u2 attribute_name_index; // 表示属性长度，固定为6 u4 attribute_length; // 表示注解数量 u2 num_annotations; // 表示注解数组 annotation annotations[num_annotations]; } 方法计数methods_count（u2）：用于描述类和接口中声明的方法，包含类级别的变量以及实例变量 方法数组methods[methods_count]（method_info）： 数据结构： method_info { // 表示方法访问标志 u2 access_flags; // 必须是CONSTANT_Utf8_info常量，表示方法名称索引 u2 name_index; // 必须是CONSTANT_Utf8_info常量，表示方法描述索引 u2 descriptor_index; // 表示方法属性总数 u2 attributes_count; // 表示方法属性数组 attribute_info attributes[attributes_count]; } 方法属性类型： Code：源代码对应的JVM指令操作码（字节码增强时主要操作的部分） Code { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为Code u2 attribute_name_index; // 表示属性长度，固定为64 u4 attribute_length; // 表示操作数栈最大深度 u2 max_stack; // 表示局部变量最大槽数 u2 max_locals; // 表示字节码长度 u4 code_length; u1 code[code_length]; // 表示异常表长度 u2 exception_table_length; // 表示异常表数组 exception_info exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count]; } LineNumberTable：行号表，将Code区的操作码和Java源码的行号对应，即Java源码走一行，需要走多少个JVM指令操作码 LineNumberTable { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为LineNumberTable u2 attribute_name_index; // 表示属性长度，固定为10 u4 attribute_length; // 表示行号表长度 u2 line_number_table_length; // 表示行号表数组 line_number_info line_number_table[line_number_table_length]; } line_number_info { // 表示字节码行号 u2 start_pc; // 表示Java源码行号 u2 line_number; } LocalVariableTable：本地变量表，包含this（对非static方法，JVM隐式传入）和局部变量 LocalVariableTable { // 必须是CONSTANT_Utf8_info常量，表示属性名索引，固定为LocalVariableTable u2 attribute_name_index; // 表示属性长度，固定为22 u4 attribute_length; // 表示本地变量表长度 u2 local_variable_table_length; // 表示本地变量表数组 local_variable_info local_variable_table[local_variable_table_length]; } local_variable_info { // 表示字节码行号 u2 start_pc; // 表示Java源码行号 u2 line_number; // 表示本地变量序号 u2 local_variable_number; // 必须是CONSTANT_Utf8_info常量，表示本地变量名称索引 u2 local_variable_name_index; } 属性计数attributes_count（u2）：用于存放在该class文件中类或接口所定义的属性的基本信息 属性数组attributes[attributes_count]（attribute_info）： 数据结构： attribute_info { // 必须是CONSTANT_Utf8_info常量，表示属性名索引 u2 attribute_name_index; // 表示属性信息表长度 u4 attributes_length; // 表示属性信息表数组 u1 info[attributes_length]; } "},"bjpowernode/01-Java基础/06-设计模式.html":{"url":"bjpowernode/01-Java基础/06-设计模式.html","title":"6. 设计模式","keywords":"","body":"[toc] 设计模式 1 创建型create 1.1 单例（Singleton） 确保一个类只有一个实例，并提供该实例的全局访问点。 1.2 简单工厂（Simple Factory） 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 1.3 工厂方法（Factory Method） 定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。 1.4 抽象工厂（Abstract Factory） 创建的是对象家族，并且这些对象是相关的，即必须一起创建出来。 1.5 生成器/建造者（Builder） 封装一个对象的构造过程，并允许按步骤构造。 1.6 原型（Prototype） 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。 2 行为型behavior 2.1 责任链（Chain Of Responsibility） 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 2.2 命令（Command） 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。 2.3 解释器（Interpreter） 为语言创建解释器，通常由语言的语法和语法分析来定义。 2.4 迭代器（Iterator） 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。 2.5 中介者（Mediator） 集中相关对象之间复杂的沟通和控制方式。 2.6 备忘录（Memento） 在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。 2.7 观察者（Observer） 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。 2.8 状态（State） 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。 2.9 策略（Strategy） 定义一系列算法，封装每个算法，并使它们可以互换。这种策略可以让算法独立于使用它的客户端。 2.10 模板方法（Template Method） 定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。 2.11 访问者（Visitor） 为一个对象结构（比如组合结构）增加新能力。 2.12 空对象（Null） 使用什么都不做的空对象来代替 NULL。 3 结构型structure 3.1 适配器（Adapter） 把一个类接口转换成另一个用户需要的接口。 3.2 桥接（Bridge） 将抽象与实现分离开来，使它们可以独立变化，即将继承改为组合，抽取其中一个维度使之成为独立的类。 3.3 组合（Composite） 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。 3.4 装饰（Decorator） 为对象动态添加功能。 3.5 外观（Facade） 提供了一个统一的对外接口，封装子系统中的一群接口，从而让子系统更容易使用。 3.6 享元（Flyweight） 利用共享的方式来支持大量的细粒度对象，把共同的部分抽象出来，针对相同的业务请求，直接返回内存中的已存在对象。 3.7 代理（Proxy） 控制对其它对象的访问。 "},"bjpowernode/01-Java基础/09-Oracle（选学）.html":{"url":"bjpowernode/01-Java基础/09-Oracle（选学）.html","title":"9. Oracle","keywords":"","body":"[toc] Oracle 1 1.1 asd "},"bjpowernode/03-Java-Web/00-summary.html":{"url":"bjpowernode/03-Java-Web/00-summary.html","title":"0. 小结","keywords":"","body":"[toc] Java Web 1 HTML+CSS+JavaScript(JS) 2 JavaScript高级（略） 3 JavaWeb 4 MVC架构 5 快速搞定AJAX 6 jQuery 7 老杜Vue（略） 8 CRM项目（略，仅部署至Linux） 9 Java生成二维码（略，仅代码） "},"bjpowernode/04-主流框架/00-summary.html":{"url":"bjpowernode/04-主流框架/00-summary.html","title":"0. 小结","keywords":"","body":"[toc] 主流框架 1 SSM源码分析 2 Maven入门 3 老杜MyBatis 4 Spring6 5 SpringMVC 6 SSH框架【选学】（略） "},"bjpowernode/06-微服务结构/02-SpringBoot3.html":{"url":"bjpowernode/06-微服务结构/02-SpringBoot3.html","title":"2. SpringBoot3","keywords":"","body":" What is SpringBoot? SpringBoot 开发运行环境要求（略） SpringBoot 程序的几种创建方式（略） SpringBoot 开发java程序（略） SpringBoot 开发web程序（略） SpringBoot main 方法分析 main方法的配置项： spring.main.sources=path：在Application类的run()方法中，可缺省primarySource这一形参 spring.main.allow-bean-definition-overriding：是否允许方法覆盖，默认为false不允许 spring.main.lazy-initialization：是否延迟初始化，默认为false不延迟 spring.main.log-startup-info：是否输出日志 spring.main.register-shutdown-hook：是否注册回调的钩子 spring.main.web-application-type：说明该项目是哪一种程序 - none：java程序 - reactive：响应式程序 - servlet：web程序 流式开发操作：Builder() main方法的启动：new SpringApplicationBuilder().sources(xxxApplication.class).bannerMode(Banner.Mode.CONSOLE).run(args); SpringBoot 项目约定的代码结构（略） SpringBoot 项目pom.xml继承结构（略） SpringBoot 项目pom.xml修改默认版本（略） SpringBoot 整合mybatis（略） SpringBoot 整合jsp视图展示（略） SpringBoot 项目pom.xml热部署插件Jrebel、devtools（略） SpringBoot 开发最佳实践 每个类都应该在package下 合理的包结构： 以业务模块为分包基础 以MVC模式为分包基础 主应用程序xxxApplication.java应与其他包同在一个根目录下，因为主类上有@SpringBootApplication的注解，默认扫描当前包及子类下的标有@Component，@Service，@Repository，@Controller等注解的bean main类上的@SpringBootApplication注解可用@EnableAutoConfiguration，@ComponentScan和@Configuration这三个注解代替 main方法的类也是一个配置类，而如今SpringBoot框架已经不推荐使用xml配置文件 将bean对象/组件加入到SpringBoot容器中： @Import(xxx.class)：直接导入bean对象 @Configuration：在要导入的bean对象的类上加上该注解 @Configuration+@Bean：加入bean对象。@Configuration加在xxxApplication类上；@Bean加在要导入的bean对象上 @Configuration+@ComponentScan：加入bean对象。@Configuration在bean对象类上必须加上；@ComponentScan可以加在bean对象上，或者是xxxApplication类上 可以使用@ImportResource(locations={\"url\"})来加入xml文件中的bean组件 禁止框架中的某些自动配置： 在项目入口类上设置@SpringBootApplication(exclude={xxx.class, ...}) 在配置文件中设置spring.autoconfigure.exclude=xxx来排除 SpringBoot项目可以直接打jar包，即可运行（因为SpringBoot已内嵌Tomcat服务器，所以无需打war包） CommandLineRunner，ApplicationRunner接口在springboot项目启动后会回调对应的重写方法（run方法） SpringBoot 敏感配置信息加密 使用jasypt加解密 加入jasypt-spring-boot-starter依赖 需要在配置文件中设置密钥jasypt.encryptor-password=xxx 使用StringEncryptor对象的encrypt(要加密的内容)和decrypt(要解密的内容)方法即可 在敏感配置信息处以ENC(加密后的内容)的格式书写即可 可修改其前后缀，设置jasypt.encryptor.property.prefix/suffix=xxx属性即可 SpringBoot 数据库连接池 SpringBoot默认采用HikariCP数据库连接池 可以更换为使用其他数据库连接池，如alibaba的druid连接池 在mybatis中排除默认的HikariCP连接池 com.zaxxer HikariCP 加入druid-spring-boot-starter依赖 SpringBoot 跨域资源共享CORS(Cross-Origin Resource Sharing) CORS允许浏览器向跨源服务器发出XMLHttpRequest请求（浏览器本身是可以发起跨域请求的，如链接一个外域的图片或脚本；但js不能获取这些外域资源内容） CORS使用一个额外的HTTP响应头来赋予浏览器获取非同源资源的权限 存在一些老版本的浏览器不支持CORS，可以采用JSONP进行跨域请求（只支持GET请求） 要在ajax中设置： dataType: \"jsonp\",：ajax发出的请求所返回的数据类型 jsonp: \"callback\",：指定一个查询参数名称来覆盖默认的jsonp回调参数名callback jsonpCallback: \"function_name\",：设置回调函数名 返回的后端数据要用回调函数包裹起来 实现代码：写一个配置类，实现WebMvcConfigurer @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"url\"); } SpringBoot 静态资源处理 默认静态资源目录位置在classpath下 有以下4个目录的静态资源可以直接访问（地址：localhost:8080/+静态资源文件名） /static /public /resources /META-INF/resources SpringBoot 核心配置文件 .properties文件和.yml文件 多环境配置文件：spring.profiles.active=dev测试/product生产 随机值：框架提供RandomValuePropertySource注入随机值（如：整数、longs、uuid或字符串） 格式：random.value/int/... 占位符：${ } 时间单位Duration：可以使用任何受支持的单位，如ns、us、ms、s、m、H、d、w、m、y等 容量单位DataSize：B、KB、MB、GB、TB等 4种配置文件读取方式： 通过@Value注解读取 通过映射类读取，类上加@ConfigurationProperties注解 通过Environment对象读取 @Autowired Environment env;：由Spring IOC提供的对象 ... env.getProperty(\"property_name\"); ... 通过嵌套静态内部类（static class）读取（如server.前缀的相关属性） SpringBoot 线程池异步调用 框架自动装配一个线程池，用于提交异步任务（用@Async注解） application上用@EnableAsync注解开启异步执行 手动配置线程池 SpringBoot 集成Swagger（OAS、springfox、swagger的关系） OAS（OpenAPI Specification），通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程 Swagger，遵循OpenAPI开发的工具框架，支持从设计和文档到测试部署的整个API生命周期的开发 SpringBoot可以集成Swagger，生成Swagger接口文档 application上用@EnableSwagger2注解开启Swagger API文档地址：http://localhost:8080/swagger-ui.html 常用注解： @Api：用在类上，说明类的作用 @ApiOperation：用在方法上，说明方法的作用 @ApiImplicitParams：用在方法上，一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 paramType：参数位置 header：@RequestHeader query：@RequestParam path：@PathVariable（用于restful接口） body form name：参数名称 dataType：参数类型 required：参数是否必须传 value：参数值 defaultValue：参数的默认值 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses注解中，用于表达一个错误的响应信息 code：数字 message：信息 response：抛出的异常类 @ApiIgnore：告知忽略这个API，在swagger生成的文档中不显示 @ApiModel：描述一个Model的信息 @ApiModelProperty：描述一个model的属性 springfox：从基于Spring的组件swagger-springmvc发展而来 springfox-swagger2：依赖OAS文档，自动生成描述API的json文件 springfox-swagger-ui：解析自动生成的json文件，以可视化的方式呈现 SpringBoot 集成websocket WebSocket协议：由HTML5定义，基于TCP协议实现的一种网络协议，可以通过该服务器主动向客户端发送信息 HTTP和WebSocket的对比： HTTP：短连接，请求后关闭连接，下次重新请求数据时，需要再次打开连接；客户端$\\to$服务器，服务器返回响应 WebSocket：长连接，只需要一次请求来初始化连接，然后所有的请求和响应都通过这个TCP连接进行通讯；服务器和客户端全双工通信 单工：信息只能单向传送 半双工：信息能双向传送但不能同时双向传送 全双工：信息能够同时双向传送 WebSocket适用场景：客户端和服务器进行频繁的双向通信时，可以避免服务器频繁创建HTTP连接 SpringBoot 注册Servlets，Filters，Listeners作为Spring Beans SpringBoot 使用拦截器Interceptor SpringBoot 内嵌Web服务器 SpringBoot默认为Tomcat Undertow：JBoss的默认服务器 Jetty：eclipse的默认服务器 SpringBoot 打包部署 jar包：不支持jsp；可以直接使用java -jar filename.jar命令运行 war包：入口类需要扩展继承SpringBootServletInitializer类 SpringBoot 配置SSL（https） 配置文件： # 配置端口号，原端口号8080失效 server.port=8443 # 配置https证书 server.ssl.key-store=classpath:tomcat.keystore server.ssl.key-store-password=123456 server.ssl.key-store-type=jks/pkcs12 生成证书： 自签名证书（测试）：JDK工具/Openssl工具 SSL证书授权中心购买（上线） SpringBoot 全局异常处理 SpringBoot 404页面处理 SpringBoot 源码分析（略） SpringBoot 自动配置原理（略） SpringBoot 中如何自定义starter?（略） "},"bjpowernode/06-微服务结构/05-Redis7.html":{"url":"bjpowernode/06-微服务结构/05-Redis7.html","title":"5. Redis7","keywords":"","body":"数据库的发展历程 单机数据库时代 Memcached时代 读写分离时代 分表分库时代（集群）：关系型数据库，如Oracle、MySql、DB2、SqlServer等 NoSQL时代：非关系型数据库（彻底改变底层存储机制，采用聚合数据结构存储数据），如Redis、mongoDB、HBase等 NoSQL数据库 Not Only SQL，泛指non-relational（非关系型数据库），去掉了关系数据库的关系型特性->数据之间一旦没有关系，使得扩展性、读写性都大大提高 为解决大规模数据集合多重数据种类带来的挑战，特别是超大规模数据的存储 数据库模型： 聚合模型：把一组相关联的数据作为一个整体进行存储和管理 BSON：数据保存到键值对中，数据之间用逗号隔开，{}表示对象，[]表示数组 { \"student\": { \"id\": 1001, \"name\": \"zhangsan\", \"course\": [ { \"courseId\": 101, \"courseName\": \"java\" }, { \"courseId\": 102, \"courseName\": \"spring\" } ] } } Redis 简介 远程字典服务器Remote Dictionary Server，是一个用C语言编写的、开源的、基于内存运行并支持持久化的、高性能的NoSQL数据库 Redis中的数据大部分时间都是存储在内存中，适合存储频繁访问、数据量比较小的数据 启动服务： 前台启动：redis-server 后台启动： redis-server & 启动redis服务时，指定配置文件：redis-server redis.conf & 关闭服务： 查看redis的pid，再kill -9 pid redis-cli shutdown 特点 支持数据持久化：Redis可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用 支持多种数据结构：不仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 支持数据备份：master-slave模式的数据备份 客户端 Redis客户端是一个程序，通过网络连接到Redis服务器。可发送命令，同时会显示Redis服务器的处理结果 redis-cli（Redis Command Line Interface），Redis自带的、基于命令行的Redis客户端，用于与Redis服务端交互 启动客户端：（windows系统中需要开两个dos窗口，一个用作redis服务，一个用作redis客户端） redis-cli：直接连接默认IP127.0.0.1，端口6379的Redis redis-cli -h 指定IP -p 端口号：连接指定IP与端口的Redis 退出客户端： exit quit 基础知识： 测试redis服务的性能：redis-benchmark 查看redis服务是否正常运行：ping，如果正常则返回PONG 查看redis服务器的统计信息： 查看所有统计信息：info 查看指定统计信息：info section redis的数据库实例： 作用类似于mysql的数据库实例，但redis中的数据库实例只能由redis服务来创建和维护，开发人员不能修改和自行创建数据库实例 默认自动创建16个数据库实例，可以通过配置文件指定redis自动创建的数据库个数 启动客户端时，默认连接0号数据库实例 部分常用命令： 切换数据库实例：select index 查看当前数据库实例中所有key的数量：dbsize 查看当前数据库实例中所有的key：keys * 清空数据库实例：flushdb 清空所有的数据库实例：flushall 查看redis中的配置信息： 查看所有配置信息：config get * 查看指定配置信息：config get parameter 5种数据结构及其操作命令 key常用操作命令： 查看数据库中的key：keys pattern 返回查询到的所有key 通配符： *：匹配0个或者多个字符 ?: 匹配1个字符 []：匹配[]里边的1个字符 判断key在数据库中是否存在：exists key [key key ....] 返回存在的key的数量 移动指定key到指定的数据库实例：move key index 查看指定key的剩余生存时间ttl（time to live）：ttl key 如果key没有设置生存时间，则返回-1 如果key不存在，则返回-2 设置key的最大生存时间：expire key seconds 设置成功则返回1，其他返回0 查看指定key的数据类型：type key 如果key不存在，则返回none 如果key存在，则返回key的数据类型 重命名key：rename key newkey 如果修改成功，则返回OK 如果key不存在，则返回(error) ERR no such key 如果newkey已存在，返回OK且覆盖旧value 删除指定的key：del key [key key .....] 返回实际删除的key的数量 字符串类型string：单key:单value 如：username:zhangsan、age:20等 能存储任何类型的数据，包括二进制数据，最大存储512M的数据 常用操作命令： 设置string数据： set key value：如果key已经存在，则后设置的value会覆盖旧value setnx key value：如果key已经存在，则放弃设置 setex key seconds value：设置字符串数据的同时，设置它最大生命周期 获取string数据：get key 追加字符串：append key value 返回追加之后的字符串长度 如果key不存在，则新建一个键值对 获取字符串数据的长度：strlen key 对字符串数值运算： 返回运算后的数据 如果key不存在，则先初始化一个key 0，再进行运算 key的value值必须是数值型，否则，报(error) ERR value is not an integer or out of range的错 命令： incr key：+1 decr key：-1 incrby key offset：+offset decrby key offset：-offset 用value覆盖从下标为startIndex开始的字符串：setrange key startIndex value 获取字符串key中从startIndex到endIndex（闭区间）的字符组成的子字符串：getrange key startIndex endIndex 下标自左至右，从0开始，依次往后 负下标自右至左，从-1开始，依次往前 批量设置string数据： 默认情况：mset key1 value1 key2 value2 ... 当所有key都不存在时设置成功，否则全部放弃设置：msetnx key1 value1 key2 value2 ... 批量获取string数据：mget key1 key2 key3 ... 列表类型list：单key:多有序value 如：contacts:xxx, xxx, xxx等 有序（按照插入顺序排序）、可重复集合，元素有（负）下标 可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用操作命令： 将一个或多个值依次插入到列表： 表头（左侧）：lpush key value [value value .....] 表尾（右侧）：rpush key value [value value .....] 获取指定列表中指定下标区间的元素：lrange key startIndex endIndex 从指定列表中移除并且返回指定元素： 表头：lpop key 表尾：rpop key 获取指定列表中指定下标的元素：lindex key index 获取指定列表的长度：llen key 根据count值移除指定列表中跟value相等的数据：lrem key count value count > 0：从列表的左侧移除count个跟value相等的数据 count count = 0：从列表中移除所有跟value相等的数据 截取指定列表中指定下标区间的元素组成新的列表且赋值给key：ltrim key startIndex endIndex 将指定列表中指定下标的元素设置为指定值：lset key index value 将value插入到指定列表中位于pivot元素之前或之后的位置：linsert key before/after pivot vlaue 集合类型set：单key:多无序value 如：city:beijing shanghai chongqin等 无序、无重复集合，元素没有下标 常用操作命令： 将一个或多个元素添加到指定的集合中：sadd key value [value value ....] 返回成功加入的元素的个数 忽略已存在的元素 获取指定集合中所有的元素：smembers key 判断指定元素在指定集合中是否存在：sismember key member 若元素存在，则返回1 若不存在，则返回0 获取指定集合的长度：scard key 移除指定集合中一个或多个元素：srem key member [member .....] 返回成功移除的元素个数 忽略不存在的元素 随机获取指定集合中的一个或多个元素：srandmember key [count] count > 0：随机获取的多个元素之间不能重复 count 从指定集合中随机移除一个或多个元素：spop key [count] 将指定集合中的指定元素移动到另一个集合中：smove source dest member 获取第一个集合key1中有的、但其它集合（key2 [key3 key4 ....]）中都没有的元素组成的新集合：sdiff key1 key2 [key3 key4 ....] 获取所有指定集合中都有的元素组成的新集合：sinter key key [key key ....] 获取所有指定集合中所有元素组成的新集合：sunion key key [key key .....] 哈希类型hash：单key:对象(属性:值) 如：student: id:1001, name:zhangsan, age:20等 适用于存储对象 常用操作命令： 将一个或多个field-value对设置到哈希表中： 普通情况下：hset key filed1 value1 [field2 value2 ....] 如果key field已经存在，会覆盖旧value值 批量设置：hmset key filed1 value1 [field2 value2 ....] 当key-field已经存在时放弃设置，否则就设置file-value：hsetnx key field value 获取指定哈希表中的field的值： 批量获取：hmget key field1 [field2 field3 ....] 获取表中所有field-value：hgetall key 从指定哈希表中删除一个或者多个field：hdel key field1 [field2 field3 ....] 获取指定哈希表中所有field的个数：hlen key 判断指定哈希表中是否存在某一个field：hexists key field 获取指定哈希表中： 所有的field列表：hkeys key 所有的value列表：hvals key 对指定哈希表中指定field值进行整数加法运算：hincrby key field int 对指定哈希表中指定field值进行浮点数加法运算：hincrbyfloat key field float 有序集合类型zset（sorted set）：单key:多有序value 如：city:1200 chongqing, 1500 shanghai, 2000 beijing等 不允许重复的成员 与list不同的是，zset中的每个元素会关联一个可重复score，redis通过score来为集合中的成员进行升序排序 常用操作命令： 将一个或多个member及其score值加入有序集合：zadd key score member [score member ....] 如果元素已经存在，则覆盖旧score 获取指定有序集合中指定区间（闭区间）的元素：（withscores会显示元素的score值） 下标区间：zrange/zrevrange key startIndex endIndex [withscores] 分数区间：zrangebyscore/zrevrangebyscore key min max [withscores] 删除指定有序集合中一个或多个元素：zrem key member [member......] 获取指定有序集合中所有元素的个数：zcard key 获取指定有序集合中分数在指定区间内的元素的个数：zcount key min max 获取指定有序集合中指定元素的排名（分数升序/降序reverse）：zrank/zrevrank key member 获取指定有序集合中指定元素的分数：zscore key member 配置文件 如果不使用配置文件，则redis会按照默认的参数运行；如果使用配置文件，则在启动redis服务时必须指定所使用的配置文件 网络配置：如果配置过，则在客户端需要连接redis服务的任何命令处，都必须指定端口和ip port：指定redis服务所使用的端口，默认使用6379 bind：配置客户端连接redis服务时所能使用的ip地址，默认为127.0.0.1，可以使用redis服务所在主机上任何一个ip tcp-keepalive：连接保活策略 常规配置： loglevel：日志级别，开发-debug，生产-notice/warning logfile：指定日志信息输出到的日志文件，默认输出到控制台 databases：配置redis服务默认创建的数据库实例个数，默认为16 安全配置： requirepass：设置访问redis服务时使用的密码，默认无密码 此参数必须在protected-mode=yes时才起作用 设置该参数后，客户端连接redis服务时，必须使用密码连接：redis-cli -h ip -p port -a pwd 持久化 概念：在适当的时机，采用适当手段把内存中的数据持久化到磁盘中。每次redis服务启动后，都可以把磁盘上的数据再次加载到内存中去使用 RDB（Redis DataBase）策略：【默认开启】在指定时间间隔内，redis服务执行指定次数的写操作，会自动触发一次持久化操作 save ：指定时间间隔和指定次数 dbfilename：配置redis RDB持久化数据存储的文件，默认命名为dump.rdb dir：配置redis RDB持久化文件所在目录 AOF（Append Only File）策略：【默认不开启】采用操作日志来记录进行每一次写操作，每次redis服务启动时，都会重新执行一遍操作日志中的指令 appendonly：配置是否开启AOF策略 appendfilename：配置操作日志文件 事务 概念： 一般情况下，把一组数据库命令放在一起执行，保证操作原子性，要么同时成功，要么同时失败 在redis中，把一组redis命令放在一起，把命令进行序列化，然后一起执行，保证部分原子性 multi：用来标记一个redis事务的开始 exec：用来执行事务队列中的所有命令$\\to$只能保证部分原子性 如果在压入事务队列过程中发生错误的命令，则本事务队列中的所有命令都不执行$\\to$保证操作原子性 如果在执行事务队列中的命令时发生了错误，则只会影响到产生错误的命令（即不执行），不会影响其它命令$\\to$无法保证操作原子性 discard：清除事务队列中的所有命令，并结束整个事务 watch：监控某一个键。当事务在执行过程中，若此键代码的值发生变化，则本事务放弃执行；否则，正常执行 unwatch：放弃监控所有的键 消息的发布与订阅 定义：客户端订阅频道，消息的发布者往频道上发布消息，所有订阅此频道的客户端都能接受到消息 subscribe channel：订阅一个或者多个频道的消息 publish channel message：将消息发布到指定频道 psubscribe pattern：订阅一个或者多个频道的消息，且频道名支持通配符 主从复制（以一主二从redis集群为例） 查看主从角色info replication：默认情况下，所有redis服务都是主机 设置主从关系slaveof ip port：遵循设从不设主的原则 全量复制：一旦主从关系确定，就会自动把主库上已有的数据同步复制到从库上去 增量复制：主库写的数据会自动同步到从库 主写从读，读写分离 主机宕机，从机原地待命；主机恢复，一切恢复正常 从机宕机，主机少一个从机，其它从机不变；从机恢复，需要重新设置主从关系 从机上位： 主机宕机，从机原地待命 从机断开原来主从关系：slaveof no one 重新设置主从关系 之前的主机恢复，主机游离在集群之外 主机如果要加入到集群之中，则可做主机也可做从机 小结：一台主机配置多台从机，一台从机又可以配置多台从机，从而形成一个庞大的Redis集群架构$\\to$可减轻一台主机的压力，但会增加服务间的延迟时间 哨兵模式（主机宕机、从机上位的自动版） 搭建一主二从集群架构 提供哨兵配置文件：需要自己创建redis_sentinel.conf，内容为sentinel monitor dc-redis ip port poll 启动哨兵服务：redis-sentinel redis_sentinel.conf 主机宕机：哨兵程序会自动投票选择从机上位 旧主机恢复，哨兵模式下自动从属于新主机 Jedis 允许在java中操作Redis，且Jedis几乎涵盖了Redis的所有命令，以同名方法的形式出现 "},"bjpowernode/06-微服务结构/08-MyBatisPlus.html":{"url":"bjpowernode/06-微服务结构/08-MyBatisPlus.html","title":"8. MyBatisPlus","keywords":"","body":"初识 MyBatis-Plus 与快速开始 增强MyBatis的功能，但不做改变 基础知识： 表对象：主键列属性要用@TableId注解 Dao接口/Mapper：继承BaseMapper的同时，指定实现的实体类 需要配置@MapperScan来扫描Mapper类所在的包 源码分析：通过动态代理实现 配置日志 在配置文件中加上mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl CRUD基本用法 CREATE UPDATE 只更新非null的属性 实体类属性建议使用包装类型来定义属性（基本类型存在默认值，会产生意外的操作） DELETE deleteById(id) deleteByMap(map)：根据map中的条件来查找删除记录 deleteBatchIds(ids)：批量删除 // 使用lambda表达式创建List集合 List ids = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList()); SELECT：如果没有查询到数据，返回null selectById(id) selectByMap(map) selectBatchIds(ids)：批量查询 ActiveRecord 每一张表对应一个类，AR可以持久化自身，并在其中已经封装了对数据库的访问，可以直接通过对象实现CRUD（不使用mapper） 实体类：继承Model（其中提供了对数据库的CRUD操作） Dao接口：这里不需要，但是MP框架需要通过这个接口来获取对应表的信息 CRUD操作： insert udpate delete：即使没有在数据库中删除记录，也会返回true select：存在记录，返回实体对象；不存在记录，则返回null 表和列 主键类型 none：无主键 auto：自动增长 input：手工输入 id_worker：实体类-Long id，列-bigint（现在最常用） id_worker_str：实体类-String id，列-varchar 50 uuid：实体类-String id，列-varchar 50 指定表名：@TableName 指定列名：@TableField 驼峰命名：实体类属性-驼峰命名，列-下划线隔开 自定义sql resources文件夹下建xml文件夹，新建映射文件 配置文件中指明地址：mybatis-plus.mapper-locations=classpath:xml/*Mapper.xml 查询和分页 查询：构造器Wrapper allEq(map, boolean)： true：处理map中的null值，where条件中加入field IS NULL false：忽略map中的null值，不作为where条件 eq/=：列名同数据库中的一致，不可用驼峰命名 ne/!= gt/> ge/>= lt/ le/ between：等同于WHERE field BETWEEN ? AND ?（两端均存在等于号） notBetween like和notLike：等同于WHERE field (NOT) LIKE %val% likeLeft和likeRight：等同于WHERE field LIKE %val/val% isNull和isNotNull in和notIn：函数in(column, values...)，等同于WHERE field (NOT) IN (?, ?, ...) inSql和notInSql：函数inSql(column, sql)，等同于WHERE field (NOT) IN (sql)，即子查询 groupBy orderByAsc和orderByDesc orderBy(boolean condition, boolean isAsc, String... columns：可指定字段和排序方向 boolean condition：orderBy是否添加到sql语句中 可在queryWrapper上追加条件 or和and：追加在其他条件函数后即可，系统默认使用and last：可在sql语句的最后再拼接sql语句 exists和notExists：拼接sql语句 分页：配置分页插件（默认为内存分页） 统计符合queryWrapper的记录数：SELECT COUNT(1) FROM table( WHERE condition) 实现分页，在sql语句末尾加上limit num1, num2 MP生成器 ``` java {.line-numbers} public static void main(String[] args) { // 创建AutoGenerator AutoGenerator autoGenerator = new AutoGenerator(); // 设置全局配置 GlobalConfig global = new GlobalConfig(); global.setOutputDir(System.getProperty(\"user.dir\") + \"/src/main/java\"); global.setMapperName(\"%sMapper\"); global.setServiceName(\"%sService\"); global.setServiceImplName(\"%sServiceImpl\"); global.setControllerName(\"%sController\"); global.setIdType(IdType.AUTO); autoGenerator.setGlobalConfig(global); // 设置数据源DataSource DataSourceConfig dataSource = new DataSourceConfig(); dataSource.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/bjpowernode\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"MySQL123!\"); autoGenerator.setDataSource(dataSource); // 设置Package信息 PackageConfig pack = new PackageConfig(); // 设置包名，该package下有mapper、service、controller等文件夹及代码 pack.setModuleName(\"order\"); // 设置父包名 pack.setParent(\"com.zj.helloplus\"); autoGenerator.setPackageInfo(pack); // 设置策略 StrategyConfig strategy = new StrategyConfig(); // underline_to_camel：驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); autoGenerator.setStrategy(strategy); // 执行自动生成 autoGenerator.execute(); } ``` "},"bjpowernode/07-互联网生态/01-Linux.html":{"url":"bjpowernode/07-互联网生态/01-Linux.html","title":"1. Linux","keywords":"","body":"[toc] Linux 1 Linux的介绍 1.1 Linux是什么？ 开源、免费的OS，注重安全性、稳定性、高并发处理能力，但没有优异的可视化界面 一般来说，windows用于个人PC机上，linux用于企业服务器上1.2 Linux主要的发行版本 最早版本：Linux的内核程序，1991年开发、发行 在内核程序的基础之上推出的不同版本的Linux OS：Ubuntu（乌班图）、RedHat（红帽）、CentOS 2 Linux的安装 2.1 安装虚拟机VM 虚拟机：可以用软件模拟出一套具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统2.2 安装CentOS linux的镜像，版本之一 3 Linux的目录结构 3.1 Linux目录结构概述 只有一个根目录/ 层级式的目录结构 graph /-->/root /root-->/root/Desktop /root-->/root/Maildir /-->/bin /-->/boot /-->/dev /-->/etc /-->/home /-->/var /-->/lib /-->/usr /usr-->/usr/bin /usr-->/usr/lib /-->/media /-->... 3.2 Linux具体目录结构 /usr/bin：存放系统的可执行文件，使得其可在任何目录下执行 /usr/local/bin：存放用户的可执行文件，使得其可在任何目录下执行 /etc：存放配置文件 /etc/profile：配置环境变量的文件 /home：用户的根目录，用于保存用户的私人数据，默认情况下该目录名与用户名一致 /opt：存放额外安装的软件 4 Linux的远程操作工具 Xshell：linux的终端模拟软件，可连接远程linux系统（在Xshell中创建会话） 查看linux系统的ip地址：ifconfig Xftp：文件传输软件，可连接远程linux系统（创建会话） 5 Linux系统管理 5.1 vi和vim的使用 两者都是linux中的文本编辑器，可用于创建、查看、编辑文本文件，但vim是vi的增强版本 模式： graph 命令行--#vim xxx-->norm[一般模式/正常模式] norm--i或a-->edit[编辑模式] edit--ESC-->norm norm--:或/-->command[命令模式] command--ESC-->norm 一般模式：可查看文件，但不能编辑文件 vim filename.txt： 如果文件存在，则进入一般模式 如果文件不存在，则创建文件并进入一般模式 编辑模式：可编辑文件，但无法保存编辑的内容 一般模式下，按i键或a键进入编辑模式 i键：光标停留在当前位置 a键：光标停留在当前位置的下一个字符位置 按Esc键，退出编辑模式回到一般模式 命令行模式：根据命令执行 一般模式下，按shift+:进入命令行模式 常用命令： q!：不保存文件并强制退出编辑器 wq：保存文件并退出编辑器 q：退出编辑器 快捷键： 复制当前行：【一般模式】yy，将光标所在行复制到剪切板；p，将剪切板中的内容粘贴到光标所在的下一行 往下复制5行：【一般模式】5yy，将光标所在行往下5行都复制到剪切板；p，将剪切板中的内容粘贴到光标所在的下一行 在文本文件中查找关键字：【命令行模式】/关键字，回车后文本中的关键字均会高亮；n，查找下一个关键字所在地 删除光标所在的当前行：【一般模式】dd 删除光标当前所在行往下5行：【一般模式】5dd 撤销上次编辑的内容：【一般模式】u 显示行号：【命令行模式】set nu，设置文件的行号；set nonu，取消显示文件的行号5.2 用户管理 用户简介：只有用户才能使用linux的系统资源；root为默认创建的系统管理员账号，拥有最高权限 添加用户：useradd [-d /dir] username 默认情况下，创建一个用户及在/home下创建一个同用户名相同的目录 如果指定目录，则会按照指定的目录名来创建 给用户设置密码：passwd username，需要输入具有一定复杂度的密码（不显示） 删除用户：userdel [-r] username，如果加上-r则会一同删除用户的目录 查询用户信息：id username 切换用户：su username 高->低：不需要密码验证 低->高：需要密码验证5.3 组管理 组简介：组相当于角色的概念，可将具有共性的用户进行统一管理；每个用户至少属于一个组，也可属于多个组 添加组：groupadd group 删除组：groupdel group 添加用户时指定组：useradd [-g group] username 将用户添加到组：gpasswd -a username group 将用户从组中移除：gpasswd -d username group5.4 系统操作 关机： 立即关机：shutdown now 定时关机：shutdown -h xxx 立即重启：shutdown -r now 立即重启：reboot 同步数据库：sync 6 Linux实操指令 6.1 帮助指令 用来查看linux系统手册上的帮助信息：man 命令 信息分屏显示 翻一行：回车 翻一页：空格 退出查看：q 用来查看命名的内置帮助信息：help 命令6.2 文件目录指令 查看当前所在目录：pwd 查看指定目录下所有的子目录和文件列表：ls [option] [dir] -l：以列表形式显示 -a：显示指定目录下所有的子目录和文件（包括虚拟的目录） -al：以列表形式显示指定目录下所有的子目录和文件（包括虚拟的目录） 切换目录：cd dir 绝对目录：以盘符开始的目录 ~：当前用户的根目录 超级管理员：/root 普通用户：/home/username 相对目录：以目录名开始的目录 ..：当前目录的上一级目录 .：当前目录 创建目录：mkdir [option] dir -p：一次创建多级目录 删除一个空目录：rmdir dir 创建一个或者多个空文件：touch file_list 文件名用空格隔开 复制文件或者目录：cp [option] source dest -r：递归复制目录 删除文件或者目录：rm [option] file/dir -f：强制删除文件 -r：提示递归删除目录 -rf：强制递归删除目录 移动目录或者文件：mv source dest source和dest均为文件时，会将source文件重命名为dest文件名 查看文件内容：cat [option] file，一次性显示文件内容 -n：显示行号 分页查看文件内容：more file，一次性加载文件中的所有内容到内存，但分页显示 按回车翻一行 按空格翻一页 分页查看文件内容：less file（比more功能更强大） 查看文件的头10行：head [option] file 查看文件的后10行：tail [option] file 输出系统变量或者常量的值到命令行终端：echo $var 将命令结果输出到指定的文件中：command > file 如果目标文件不存在，则新建一个文件 如果目标文件已存在，则覆盖文件内容 将命令结果追加输出到指定的文件中：command >> file 如果目标文件不存在，则新建一个文件 如果目标文件已存在，则在文件原来的内容上追加6.3 时间日期指令 查看或者设置系统的日期或者时间：date [command] 查看系统当前的完整的日期和时间：date 系统当前的年份：date +%Y 系统当前的月份：date +%m 系统当前的日期：date +%d 查看系统日期：date '+%Y-%m-%d %H:%M:%S'（按yyyy-MM-dd HH:mm:ss格式显示） 设置当前的系统时间：date -S 'yyyy-MM-dd HH:mm:ss' 查看系统日历：cal [command] 查看当前月份的日历：cal 查看指定年份的日历：cal yyyy6.4 搜索查找指令 普通搜索：find [range] [standard] keyword -name：默认按名称搜索（文件或者目录所在的路径也在搜索范围之内） -size：按文件大小搜索 -user：按文件的所有者搜索 在整棵目录树中搜索文件或者目录（根据名称搜索）：locate keyword updatedb：更新数据库 搜索过滤命令（即在前一个搜索命令的结果中按名称进一步过滤）：搜索/查看命令 |grep [option] condition6.5 压缩和解压缩指令 压缩/解压单个文件： gzip file：压缩单个文件，生成一个.gz的压缩包，并会把原来的文件删除 gunzip package.gz：解压.gz压缩包，并把原来的.gz压缩包删除 压缩（打包）/解压多个文件和目录： zip package.zip file/dir_list：将文件列表或目录列表压缩到压缩包中 unzip package.zip[ -d dir]：将指定的.zip压缩包解压到当前目录/指定目录 压缩（打包）/解压多个文件和目录：tar [option] xxx.tar.gz file/dir_list -zcvf：打包或者压缩 -zxvf：解压6.6 组管理指令 linux系统的用户分类：文件或目录通过组来控制用户的访问权限 所有者：默认情况下，文件或者目录的所有者都是创建者，可以修改 同组用户：和文件或者目录属于同一个组的用户 其它组用户：既不是文件或者目录的所有者，也不是同组用户 查看文件的所有者和所在的组：ls -l 修改文件或者目录的所有者（change ownship）：chown new_owner:new_group file/dir 修改文件或者目录的所在组（change group）：chgrp new_group file/dir6.7 权限管理指令 文件或者目录的三种权限： 读Read：可以读取、查看文件的内容 写Write：可以修改文件的内容 执行Execute：若该文件是可执行文件(.sh)，则可直接运行 文件或者目录的权限控制：使用r、w、x来表示读、写、执行的权限 所有者权限 同组用户权限 其它组用户权限 查看文件或者目录的权限：ls -aul 修改文件或者目录的权限：chmod command 字母的形式：如chmod g-w,o+w t5.txt r、w、x：读、写、执行的权限 u、g、o、a：给所有者、同组用户、其它组用户、所有用户修改权限 +、-、=：给指定的用户增加、减少、设置对应的权限 数字的形式：如chmod 753 t5.txt r、w、x：4、2、1 每一个文件或者目录都有三部分权限，每一部分权限都可以用一组数据之和来表示，三部分权限就是一组三个数据序列 7 网络配置 查看和配置网络 配置Linux网络：vi /etc/sysconfig/network-scripts/ifcfg-ens33 BOOTPROTO=\"static\" --> 获取ip的方式 ONBOOT=\"yes\" IPADDR=192.168.11.128 --> 设置静态ip地址（从虚拟网络编辑器设置的范围中选取一个） GATEWAY=192.168.11.2 --> 设置网关（在虚拟网络编辑器NAT中查看） DNS=192.168.11.2 --> 设置DNS（同网关一致） 8 进程管理 进程介绍 线程：一个程序的线路 进程：一个程序的执行，一个进程占用一个端口 查看系统运行的进程：ps [option] 为空：只显示应用进程 -e：显示所有进程 -ef：以全格式的形式显示所有进程 -ef|grep keyword：根据关键字查找进程信息 终止进程：kill id PID 服务管理 服务介绍：服务是支持Linux运行的一些必要程序，本质上也是进程，叫守护进程 操作服务：systemctl [start|stop|restart|reload|status|enable] serve 9 Linux软件包管理 9.1 RPM包的管理 简介：一种Linux的软件包的打包和安装工具，它操作的软件包都是.rpm结尾 命令： 查看当前系统中已经安装的rpm软件包：rpm -qa|grep keyword 卸载rpm软件包：rpm -e keyword 安装rpm包：rpm -ivh xxx.rpm9.2 YUM包的管理 简介：一种基于RPM的软件包管理工具，它能够从指定服务器上自动下载RPM包并且自动安装，可以自动处理软件包之间的依赖关系 命令： 查看当前系统中已经安装的rpm软件包：yum list installed|grep keyword 卸载rpm软件包：yum remove xxx.xxx 安装rpm包：yum install keyword 10 搭建JAVA EE开发环境（略） "},"bjpowernode/jpa.html":{"url":"bjpowernode/jpa.html","title":"JPA","keywords":"","body":"1 JPA概述 1.1 JDBC Java DataBase Connectivity，用于执行sql语句的Java API，可为多种关系数据库提供统一访问 1.2 持久层框架 Hibernate： 开源、轻量级的ORM工具：对象-关系映射ORM（Object Relation Mapping） 业务数据-内存-对象 业务数据-数据库-表中行graph LR 对象--ORM-->表中行 简化操作：在Java中直接操作对象就是在操作数据库中的表 （便于不熟悉SQL语句的开发人员） MyBatis： 支持定制化SQL：开发人员需要熟练使用SQL语句 使用简单的XML或注解来配置，可将接口和POJOs映射成数据库中的记录 1.3 JPA是什么 Java Persistence API，使用JDK5.0注解或XML文件描述对象-关系表的映射关系，并将运行的实体对象持久化到数据库中 graph TB a[Java应用程序]-->b[JPA规范:接口和方法] b-->c[Hibernate]-->数据库 b-->EclipseLink-->数据库 b-->OpenJPA-->数据库 b-->其他ORM框架-->数据库 a-->c 1.4 JPA规范版本（略） 1.5 JPA实现（供应商） Hibernate、OpenJPA、EclipseLink 1.6 JPA优势 标准化 简单易用、集成方便 可媲美JDBC的查询能力 支持面向对象的高级特性 1.7 JPA的三方面技术 ORM映射元数据：JPA支持XML和JDK5.0注解两种元数据的形式 元数据描述对象和表之间的映射关系 框架根据元数据将实体对象持久化到数据库表中 JPA的API：用于操作实体对象 查询语言（JPQL）：通过面向对象而非面向数据库的查询语言查询数据 1.8 JPA和Hibernate JPA是规范：JPA本质上是一种ORM规范，提供一些API接口，并未提供ORM实现 Hibernate是实现：Hibernate实现JPA规范，还扩展了其他功能 1.9 JPA和MyBatis JPA：JPA规范 对象和对象的映射 移植性较好 面向对象 MyBatis：独立框架 对象和结果集的映射 移植性差，项目移植时需要修改sql语句 面向SQL 2 JPA应用 2.1 JPA应用关键步骤 创建persistence.xml（固定文件名称），文件放在类路径的META-INF目录下（固定文件位置） 创建JPA单元，一个单元指定一个数据库的相关信息 配置数据库的属性，连接到指定数据库 指定JPA的实现提供者（Hibernate、OpenJPA）：若只有一个实现，默认可不写 指定实体类的信息 创建实体类，使用注解或xml配置文件来描述实体类跟数据库表之间的映射关系 使用JPA API完成对数据的CRUD操作 EntityManagerFactory EntityManager EntityTransaction 2.2 JPA注解 @Entity 指出该类为实体类，映射到指定的数据库表上 用于实体类声明语句之前 @Table 当实体类与其映射的数据库表名不一致时使用该注解标注说明 用于实体类声明语句之前，与@Entity并列使用 属性： name：数据库的表名 catalog：数据库模式 schema：数据库名 uniqueConstraints：约束条件，通常不设置 @Id 声明一个实体类的属性映射为数据库表的主键列 用于属性声明语句之前，或置于属性的getter方法之前 @GeneratedValue 标注主键的生成策略 与@Id并列使用 通过strategy属性指定具体策略： IDENTITY：自动增长，mysql支持（oracle不支持） AUTO：自动根据框架选择主键的方式，默认选项 SEQUENCE：序列，oracle支持（mysql不支持） TABLE：通过表产生主键，框架借助表模拟序列产生主键，移植性较好 @Basic 表示一个简单的属性到数据库表的字段的映射，在@Entity标注下的类中，若无任何标注的属性，默认即为@Basic 用于属性声明语句之前，或置于属性的getter方法之前 属性： fetch：属性的读取策略 EAGER：主支抓取，默认策略 LAZY：延迟加载 optional：是否允许该属性为null，默认为true @Column 当实体的属性与其映射的数据库表的列不同名时使用该注解标注说明 用于属性声明语句之前，或置于属性的getter方法之前 （可与@Id一起标注） 属性： name：设置映射数据库表的列名 columnDefinition：表示该字段在数据库中的实际类型 通常情况下，ORM框架可以根据属性类型自动判断数据库中字段的类型 Date类型：无法确定数据库中到底是DATE/TIME/TIMESTAMP String类型：默认映射类型为VARCHAR，如果要映射到特定类型，如BLOB或TEXT字段类型，则可在此声明 其他属性：unique、nullable、length等 @Transient 表示属性并不是数据库表的字段，ORM框架会忽略该属性 用于属性声明语句之前，或置于属性的getter方法之前 @Temporal 用于调整精度，如Date类型，可使用该注解来指定在数据库中的具体类型 用于属性声明语句之前，或置于属性的getter方法之前 3 JPA实体操作 3.1 实体管理器 实体管理器EntityManager，用于操作实体的读取、持久化、删除等，由EntityManagerFactory创建 持久化上下文（persistence context）：在任何时间管理的所有实体集合。在其中，具有相同持久化标识的java实体只存在一个 实体管理器EntityManager/实体管理器工厂EntityManagerFactory/持久化单元persistence unit三者关系： graph factory[EntityManagerFactory]--1:1-->unit[persistence unit] factory--1:n-->EntityManager 3.2 创建EntityManagerFactory 使用Persistence创建EntityManagerFactory对象 createEntityManagerFactory() createEntityManagerFactory(Map map)：map用于提供EntityManager属性 使用EntityManagerFactory对象的createEntityManager()创建createEntityManager 常用方法： isOpen()：检查EntityManagerFactory是否处于打开的状态（创建实例后，即处于打开状态） close()：关闭EntityManagerFactory，关闭后将释放所有资源 3.3 持久化实体 EntityManager提供persist()方法，用于插入数据到表 3.4 查找实体 EntityManager提供find()与getReference()方法，根据主键搜索实体，查找到的实体存在于当前持久化上下文中 find()：立即执行，若未查找到对象则返回null getReference()：延迟查询，只有当程序使用对象时，才执行查询操作；通过该方法获取到的对象是代理对象，若未查找到对象则会报EntityNotFoundException异常，而不是返回null 3.5 更新实体 托管：实体由EntityManager管理 要更新的实体必须是已被托管的，因此需要先使用find获取实体，再修改实体的数据（修改完提交事务即可实现持久化） 3.6 删除实体 EntityManager提供remove()方法，用于删除特定的已被托管的记录 4 JPA集合映射 4.1 概念 集合映射：实体中集合类型的属性，常用集合List、Set、Map等；只有集合中的数据和当前实体一起，才能表示一个完整的数据 集合中存储的对象： 基本类型 可嵌入对象：类上面加上@Embeddable注解表示可嵌入类型，其作为实体的一部分会变得可持久化 集合表：集合数据特有的表，其中有一列为联接列（类似外键到主键的引用），使用@CollectionTable指定集合表的名称和联接列的名称 4.2 没有集合表的可嵌入类型 可嵌入对象数据存在实体表 新建嵌入类，加上@Embeddable注解 在实体类中设置嵌入类属性，并加上@Embedded注解 嵌入类的所有属性作为实体类的一部分建表 修改可嵌入对象映射列 修改实体类中的嵌入类映射到数据库表中的列名，加上与@Embedded注解并列的@AttributeOverrides注解，在其中设置列名即可 ``` java {.line-numbers} @Embedded @AttributeOverrides({ @AttributeOverride(name = \"属性名\", column = @Column(name = \"列名\")), }) private 嵌入类对象 变量名; ``` 4.3 集合表 4.3.1 基本类型 Set集合 结果：生成两张表 实体表 集合表：实体类名_集合类型的属性名，使用@CollectionTable注解可以自定义集合表 联接列：实体类名称_实体类的主键列名称 特征列：集合类型的属性名 ``` java {.line-numbers} @ElementCollection @CollectionTable( name = \"集合表名\", joinColumns = @JoinColumn(name = \"联接列名\") ) @Column(name = \"特征列名\") private Set 属性名; ``` List集合 结果类似于Set集合，但是List可以排序 ``` java {.line-numbers} @ElementCollection @OrderBy(\"嵌入类型的属性名1 ASC/DESC, 属性名2 ASC/DESC, ..., 属性名n ASC/DESC\") private List 属性名; ``` 通用集合类型Collection 结果类似于Set集合，但是需要在注解中指定集合类型的具体类型 ``` java {.line-numbers} @ElementCollection(targetClass = 具体类型.class) private Collection 属性名; ```4.3.2 嵌入类 Set集合 结果类似于基本类型的Set集合，但集合表的结构不同，表中列均为嵌入类的属性 Map集合 结果类似于Set集合，但多了一列集合的key值，可用@MapKeyColumn注解来指定Map类型中key值对应列的定义 "}}