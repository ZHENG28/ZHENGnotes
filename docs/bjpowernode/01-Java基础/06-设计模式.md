---
sidebar_label: 6. 设计模式
---

# 设计模式

## 1 创建型create
### 1.1 单例（Singleton）
- 确保一个类只有一个实例，并提供该实例的全局访问点。

### 1.2 简单工厂（Simple Factory）
- 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

### 1.3 工厂方法（Factory Method）
- 定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

### 1.4 抽象工厂（Abstract Factory）
- 创建的是对象家族，并且这些对象是相关的，即必须一起创建出来。

### 1.5 生成器/建造者（Builder）
- 封装一个对象的构造过程，并允许按步骤构造。

### 1.6 原型（Prototype）
- 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。

---

## 2 行为型behavior
### 2.1 责任链（Chain Of Responsibility）
- 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。

### 2.2 命令（Command）
- 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。

### 2.3 解释器（Interpreter）
- 为语言创建解释器，通常由语言的语法和语法分析来定义。

### 2.4 迭代器（Iterator）
- 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。

### 2.5 中介者（Mediator）
- 集中相关对象之间复杂的沟通和控制方式。

### 2.6 备忘录（Memento）
- 在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。

### 2.7 观察者（Observer）
- 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。

### 2.8 状态（State）
- 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。

### 2.9 策略（Strategy）
- 定义一系列算法，封装每个算法，并使它们可以互换。这种策略可以让算法独立于使用它的客户端。

### 2.10 模板方法（Template Method）
- 定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

### 2.11 访问者（Visitor）
- 为一个对象结构（比如组合结构）增加新能力。

### 2.12 空对象（Null）
- 使用什么都不做的空对象来代替 NULL。

---

## 3 结构型structure
### 3.1 适配器（Adapter）
- 把一个类接口转换成另一个用户需要的接口。

### 3.2 桥接（Bridge）
- 将抽象与实现分离开来，使它们可以独立变化，即将继承改为组合，抽取其中一个维度使之成为独立的类。

### 3.3 组合（Composite）
- 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。

### 3.4 装饰（Decorator）
- 为对象动态添加功能。

### 3.5 外观（Facade）
- 提供了一个统一的对外接口，封装子系统中的一群接口，从而让子系统更容易使用。

### 3.6 享元（Flyweight）
- 利用共享的方式来支持大量的细粒度对象，把共同的部分抽象出来，针对相同的业务请求，直接返回内存中的已存在对象。

### 3.7 代理（Proxy）
- 控制对其它对象的访问。