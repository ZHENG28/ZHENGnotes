---
sidebar_label: 15. 高并发解决方案
---

# 高并发解决方案

## 1. 概述
### 1.1. 什么是高并发
- 高并发：大量并发访问，即某个时间点有大量请求同时来访问系统；日PV（Page View，页面浏览量或点击量）在千万以上
- 衡量指标：
    1. 响应时间：系统对请求做出响应的时间
    2. 吞吐量：单位时间内能处理的用户请求数量
    3. QPS：系统每秒能够响应的查询次数，即服务器在每秒内能处理多少流量
    4. 并发用户数：同时能承载用户正常使用系统功能的用户数量

### 1.2. 常见的高并发应用
1. 淘宝双十一
2. 京东618
3. 12306抢票

---

## 2. 解决方案
### 2.1. 硬件
- 单体应用垂直扩容：提升服务器硬件配置的策略
    - 单体应用/集中式应用：完成产品只需要一个项目工程
- 单体应用垂直扩容方案：
    1. CPU：32位提升到64位
    2. 内存：64GB提升到256GB
    3. 磁盘：HDD（Hard Disk Drive）提升到固态硬盘SSD（Solid State Drives）
    4. 磁盘容量：1TB提升到2TB
    5. 网卡：千兆提升到万兆

### 2.2. 缓存
1. HTTP缓存：
    1. 浏览器缓存：浏览器根据服务器端返回的缓存设置，将响应内容缓存到浏览器
        - 响应码 `304`：无需再次传输请求的内容，即可以使用缓存内容
        - 设置响应头
    2. Nginx缓存：Nginx拦截请求后，会先从Nginx本地缓存查询数据
        - 提供 `expires` 指令来实现缓存控制
    3. CDN（Content Delivery Network，内容分发网络）缓存：依靠部署在各地的 **边缘服务器**，通过中心平台的负载均衡、内容分发、调度等能力，使用户 **就近** 获取所需内容
        - 主要缓存静态资源
        - 数据传输链路：从用户浏览器到各级（区、市、省）网络，再跨省远距离传输到目标服务器
2. 应用缓存：
    1. 内存：高效快速，但重启后缓存丢失
    2. 磁盘：读取效率低，但重启后缓存不会丢失
        - 代码组件：`Guava`、`Ehcache`
        - 服务器：`Redis`、`MemCache`
3. 多级缓存：在应用系统的不同层级进行数据缓存，如浏览器 &rarr; CDN &rarr; Nginx &rarr; Redis &rarr; DB（磁盘、文件系统）
4. 使用场景：目的是减少对后端服务的访问，降低服务器压力
    1. 经常需要读取的数据
    2. 频繁访问的数据
    3. IO瓶颈数据
    4. 计算昂贵的数据
    5. 无需实时更新的数据

### 2.3. 集群
- 单体应用水平扩容：即集群部署；必须需要负载均衡

### 2.4. 拆分
1. 应用拆分：分布式、微服务
    - 远程调用技术：`httpClient`、`hessian`、`dubbo`、`webService` 等
    - 开源方案：`Dubbo`、`SpringCloud` 等
2. 数据库拆分：
    - 分类：
        1. 垂直拆分（分库）：按照业务维度，把相同类型的表放在一个数据库里，即不同库建不同表
        2. 水平拆分（分表）：根据数据行的特点和规则，将表中某些行切分到不同数据库里
    - 开源方案：`MyCat`、`Sharding-Sphere` 等

### 2.5. 静态化
- 对于访问量大且更新频率低的数据，可定时生成静态页面
- 静态化技术：`freemaker`、`velocity`

### 2.6. 动静分离
- Nginx负责代理静态资源，Tomcat负责处理动态资源

### 2.7. 队列
- 作用：
    1. 异步处理
    2. 流量削峰：高峰期将请求暂时入队，将流量削平，避免服务器压力过大
    3. 系统解耦：发消息通知其它系统，而非直接调用
- 应用场景：
    1. 非必须实时处理的
    2. 非必须实时告知用户结果的
    3. 非必须100%一次性处理成功的
    4. 非必须强一致性的（保证最终一致性即可）
- 常见的消息队列产品：
    1. `ActiveMQ`
    2. `RabbitMQ`
    3. `RocketMQ`
    4. `kafka`

### 2.8. 池化
1. 对象池：`commons-pool2`
2. 数据库连接池：`Druid`、`DBCP`、`C3P0`、`BoneCP`
3. Redis连接池：`JedisPool`
4. HttpClient连接池：`PoolingClientConnectionManager`
5. 线程池：`java.util.concurrent` 包

### 2.9. 优化
1. JVM优化：
    1. `server`：VM的运行模式
        1. `Server` 模式：启动较慢，但程序运行速度快
        2. `Client` 模式：启动较快，但程序运行速度慢
    2. `-Xmx2g`：最大堆大小
    3. `-Xms2g`：初始堆大小
    4. `-Xmn256m`：堆中年轻代大小
    5. `-XX:PermSize`：非堆内存初始值，默认是物理内存的1/64
    6. `-XX:MaxPermSize`：最大非堆内存初始值，默认是物理内存的1/4
    7. `-Xss`：每个线程的Stack大小
    8. `-XX:+DisableExplicitGC`：禁止代码中显式调用GC
    9. `-XX:CMSInitiatingOccupancyFraction`：使用率达到70%时开始CMS垃圾回收
2. Tomcat优化：
    1. 设置JVM参数
    2. 设置Tomcat的线程池大小
    3. 设置IO模式
    4. 配置APR

### 2.10. Java程序优化
- 优化方向：
    1. 不重复创建对象
    2. 流/文件/连接要在 `finally` 块中关闭
    3. 少用重量级同步锁 `synchronized`，可采用 `Lock`
    4. 不要在循环体中使用 `try/catch`
    5. 多定义局部变量，少定义成员变量

### 2.11. 数据库优化
1. 数据库服务器优化：修改数据库服务器的配置文件的参数
2. 数据库架构优化：
    1. 将数据库服务器和应用服务器分离
    2. 读写分离 &rarr; 分摊读写压力
    3. 分库分表
3. 数据库索引优化：
    1. 优化方向：
        1. 索引字段尽量小，最好是数值（字符串做比对 &rarr; 效率低）
        2. 在唯一性高的字段上创建索引，如主键、序号等
        3. 不要过多地建立索引（索引需要单独存储 &rarr; 降低更新效率）
    2. 索引结构分类：
        1. BTree索引（默认）：最多只需要 **3次磁盘IO** 就能判断数据是否存在以及数据的引用位置
            1. 第1次磁盘IO：根节点 &rarr; 子节点
            2. 第2次磁盘IO：子节点 &rarr; 叶子节点
            3. 第3次磁盘IO：从叶子节点中获取所有数据（索引值-数据值）
        2. Hash索引：适用于字符串类型的索引，但不适用于区间查询
            1. 由索引值得出固定的哈希值
            2. 根据 `索引值 % 哈希值` 的结果得到数据节点位置（索引值、哈希值、数据的引用位置）
        3. 位图索引（Mysql不支持）：索引重复率越高 &rarr; 效率越高
            | 索引值&darr; \| 记录行号&rarr; | 1 | 2 | 3 | 4 | 5 |
            | :--: | :--: | :--: | :--: | :--: | :--: |
            | 男 | 0 | 1 | 0 | 0 | 1 |
            | 女 | 1 | 0 | 1 | 1 | 0 |
    3. 索引类型：
        1. 聚簇/聚合/聚类索引（主键）：索引在索引结构中的相对位置与数据在表中的相对物理位置保持一致；建议使用int或bigint
        2. 非聚簇索引：普通索引
4. SQL优化：`EXPLAIN` 执行计划分析 &rarr; 避免引擎放弃使用索引而全表扫描
    1. 在 `where` 及 `order by` 涉及的列上建立索引
    2. 不在 `where` 子句中对字段进行null值判断
    3. 不在 `where` 子句中使用 `!=` 或 `<>` 操作符
    4. 不在 `where` 子句中使用 `or` 连接符
    5. 不在 `where` 子句中使用 `in` 和 `not in`
    6. 不在 `where` 子句中使用模糊查询
    7. 不在 `where` 子句中使用表达式
    8. 不在 `where` 子句中使用函数
    9. 必须使用复合索引的第一个字段作为条件 &rarr; 引擎才会使用索引
    10. 不写无意义的查询
    11. 用 `exists` 代替 `in`
    12. 索引列不宜有过多重复数据
    13. 索引能提高 `SELECT` 效率，但降低了 `INSERT` 和 `UPDATE` 效率
    14. 索引尽量使用数值类型
    15. 用 `varchar` 代替 `char`（变长字段存储空间小）
    16. `SELECT` 中用具体字段名代替 `*`
    17. 避免大事务操作 &rarr; 提高系统并发能力
5. 采用数据搜索引擎：`solr`、`elasticsearch`

### 2.12. Nginx优化
1. 调整配置文件参数
    ```nginx showLineNumbers
    worker_processes 16;
    gzip on; #开启gzip压缩输出
    events {
        worker_connections 65535;
        multi_accept on; #开启多路连接
        use epoll; #使用epoll模型
    }
    ```

### 2.13. Linux优化
1. 优化Linux内核参数：`/etc/sysctl.conf`

### 2.14. 网络优化
1. 优化机房、带宽、路由器等
2. 设计网络架构

### 2.15. 前端优化
1. js优化：
    1. 压缩
    2. 多个合并成一个js文件
2. css优化：
    1. 压缩
    2. 多个合并成一个css文件
3. html页面优化：
    1. 不加载太多的js和css文件
    2. js和css的加载放在页面尾部
    3. 页面上减少请求数

### 2.16. 压力测试
1. 工具：`Apache JMeter`、`LoadRunner` 等

### 2.17. 总结