---
sidebar_label: 10. MySQL优化
---

# MySQL优化

## 1 简介
### 1.1 概述
1. 查询慢的原因：
    1. 有规律地慢：用户访问量激增 &rarr; MySQL集群
    2. 无规律地慢：表中数据量变多 &rarr; 优化查询语句
2. 判断查询语句是否需要优化的工具：
    1. 慢查询记录：查询时间长短
    2. `explain` 执行计划：索引是否生效
    3. 相关日志文件：用户查询习惯等

### 1.2 查询语句关键词（按照执行优先级由高到低排序）
1. `FROM`：将硬盘上的表文件加载到内存中，生成一张 **<font color="red">临时表</font>** ；定位内存中的临时表
    1. 查询语句中，第一个执行的永远是 `FROM` 命令
    2. 由于定位的是一张临时表，因此必须手动指定表名
2. `WHERE`：**循环遍历**临时表中的每一行记录，将满足条件的记录保存到一张 **<font color="red">新</font>临时表** 中
    1. 由于 `WHERE` 命令每次操作的都是一行记录，因此无法使用聚合函数作为判断条件
3. `GROUP BY`：对临时表中的记录进行排序，将具有相同特征的记录保存到一张 **<font color="red">新</font>临时表** 中
    1. 多字段分组：字段执行的先后顺序对查询结果没有影响；从第二个字段开始，每次操作的临时表都是对前一个字段分组后生成的 **<font color="red">新</font>临时表**
    2. 若 `SELECT` 命令操作的临时表是由 `GROUP BY` 命令生成的，则 `SELECT` 命令会遍历由 `GROUP BY` 命令生成的每一张临时表，读取指定字段中的第一行记录内容
4. `HAVING`：将 `GROUP BY` 生成的临时表中不满足条件的记录删除
    1. `HAVING` 命令只能出现在 `GROUP BY` 命令后
    2. `HAVING` 命令每次操作的都是一张临时表，因此判断条件应该来自于聚合函数
5. `SELECT`：
    - 由 `FROM` 或 `WHERE` 命令生成的临时表：将指定字段中的所有内容都读取出来，组成一张 **<font color="red">新</font>临时表**
    - 由 `GROUP BY` 和 `HAVING` 命令生成的临时表：遍历生成的每一张临时表，并只读取指定字段中的第一行记录内容，生成一张 **<font color="red">新</font>临时表**
6. `ORDER BY`：对临时表中的记录进行排序，将排序后的内容组成一张 **<font color="red">新</font>临时表** 
    1. 使用字段名排序时，字段名可以不出现在临时表中
    2. 使用字段顺序排序时，字段必须显式出现在临时表中
7. `LIMIT`：对临时表中的记录行进行 **截取**

### 1.3 查询语句的特征与优化项分析
1. 特征：
    1. 除了 `HAVING` 命令外，其余6个命令执行后均会生成**新**临时表
    2. 除了 `FROM` 命令外，其余6个命令操作的临时表均是由上一个命令执行后生成的临时表
    3. 当前命令执行结束后，mysql会自动将上一个命令生成的临时表销毁
2. 优化项：（按照执行速度由慢到快排序）
    1. `GROUP BY`：先排序，再分组
    2. `ORDER BY`：先排序，再生成一张临时表
    3. `WHERE`：遍历表中的所有记录（数据量大时，速度非常慢）
    4. `LIMIT`：指定的行数过大时，会导致速度慢
    5. 多表查询：未指定表的加载顺序时，也会导致速度慢

---

## 2 索引
### 2.1 概述
1. 索引，本质是一组排好顺序的数据
    1. 避免数据在查询时再次排序 &rarr; 速度慢
    2. 避免在定位记录行时扫描全表（遍历查找） &rarr; 速度慢
2. 索引文件位置：
    1. `INNODB` 存储引擎：存在 `.frm` 文件中
    2. `MYISAM` 存储引擎：存在 `.myi` 文件中
3. 基本操作命令：
    1. `CREATE INDEX index_name ON table_name(field_name)`：创建索引
    2. `SHOW INDEX FROM table_name`：查看表中的索引
    3. `DROP INDEX index_name ON table_name`：删除索引

### 2.2 分类
1. 聚簇索引和非聚簇索引：
    1. **聚簇索引**：自动创建在主键字段 &rarr; （无主键）唯一约束字段 &rarr; （无唯一约束）随机字段
        - **<font color="red">数据节点 = 当前数据所在行数 + 当前数据行内容</font>**：查询时，可直接定位到数据节点上，读取数据内容，无需从硬盘中读取 &rarr; 执行速度**快**
        - 只能来自于采用了 `INNODB` 存储引擎的表
        - 在采用 `INNODB` 存储引擎的表文件中，必然存在也只有一个聚簇索引
        - 表中其他索引都是非聚簇索引
    2. **非聚簇索引**：由开发者自行创建
        - **<font color="red">数据节点 = 当前数据所在行数</font>**：查询时，由于数据节点中只有数据所在行数，因此需要从硬盘中读取数据内容 &rarr; 执行速度**慢**
        - 在采用 `MYISAM` 存储引擎的表文件中，所有索引都是非聚簇索引
2. 主键索引和唯一性索引：执行效率上来说，主键索引 &gt; 唯一性索引 &gt; 普通索引
    1. **主键索引**：主键约束生成的索引
    2. **唯一性索引**：唯一约束生成的索引（不包含 `NULL` ）
    3. **普通索引**：字段上没有任何约束生成的索引
3. 单个索引和复合索引：
    1. **单个索引**：`CREATE INDEX index_name ON table_name(field_name)`
    2. **复合索引**：`CREATE INDEX index_name ON table_name(field1_name, field2_name, ...)`

### 2.3 索引算法
1. **二分查找算法**：可避免对整体数据进行扫描，每次只需扫描一半的数据；但数据量过大时，该算法的效率较低
    ```mermaid
    graph LR
    小于平均值的数据 --- root[根节点（平均值）] --- 大于平均值的数据
    ```
2. **平衡二叉树算法**：二分查找算法的升级版；但索引的字段数据发生变化时会重新创建平衡二叉树，存在多个查询条件时会多次遍历二叉树和多次I/O读取内容
    ```mermaid
    graph TD
    root[根数据节点] --- 小于根节点的数据节点 --- leaf[叶子节点 = 数据行数 + 数据内容]
    root --- 大于根节点的数据节点 --- ...
    ```
3. **<font color="red">B-TREE算法</font>**：平衡二叉树算法的升级版，目前各种数据库主要使用的索引算法
    ```mermaid
    graph TD
    root[区间数据] --- 小于区间数据的区间数据 --- leaf1[叶子节点 = 数据行数 + 数据内容]
    root --- 大于区间数据的区间数据 --- leaf2[叶子节点...]
    
    ```
    - 使用区间数据来代替具体数据 &rarr; 降低维护难度
    - 在连续叶子节点之间使用**指针**来连接 &rarr; 降低遍历次数
4. **哈希算法**：只有 `MEMORY` 存储引擎才支持，基于哈希表实现
    - 索引 = 哈希码 `hash code` + 指向数据行的指针

---

## 3 `EXPLAIN` 执行计划
### 3.1 基本结构
![Explain Structure](./img/10.1.explain_structure.jpg)
1. `id`：查看表的加载顺序
    1. `id` 相同：自上而下地顺序加载表文件
    2. `id` 不同：`id` 从大到小地加载表文件
2. `select_type`：查看sql的查询类型
    1. `SIMPLE`：简单的查询语句，不包含子查询、联合查询、连接查询等
    2. `PRIMARY`：包含子查询的查询语句，或联合查询语句中的第一个查询语句
    3. `DEPENDENT SUBQUERY`：子查询语句，且有执行条件依赖于外部查询语句
    4. `SUBQUERY`：子查询语句
3. `type`：查看评价级别（按照执行效率从高到低排序） &rarr; 优化时，级别应该在 `RANGE` 和 `REF` 级别之间
    1. `SYSTEM`：操作表只有一行数据，且数据内容固定不变
    2. `CONST`：使用**主键**索引与**直等**方式定位数据行
    3. `REF`：使用索引与**直等**方式定位数据行
    4. `RANGE`：使用索引与**区间**方式定位数据行
    5. `INDEX`：定位数据行时，全表扫描；但在使用 `SELECT` 命令时，根据索引读取数据
    6. `ALL`：**全表**扫描，没有任何索引可以使用
4. `possible_keys`：查看本次查询可能使用到的索引
5. `key`：查看本次查询实际使用到的索引
6. `key_len`：查看实际使用的索引的长度，越长查询精度越高
    - 不同数据类型所占的字节数也不同
7. `ref`：查看实际使用的索引在查找时用到的是常量 `CONST` 还是列名 `FIELD_NAME`
8. `rows`：查看优化器读取的行数
9. `Extra`：其他额外信息

### 3.2 使用规则
1. 在索引字段上使用**函数** &rarr; 索引失效
2. 在索引字段上使用**运算** &rarr; 索引失效
3. 索引字段上产生了**隐式类型转换** &rarr; 索引失效
4. 索引字段上进行模糊查询：
    1. 右模糊 &rarr; 索引<font color="red">生效</font>
    2. **左**模糊 &rarr; 索引失效
    3. **左右**模糊 &rarr; 索引失效